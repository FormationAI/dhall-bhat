    let Monad =
          ./../Monad/Type Type (./../uncurryT Type Type Type ./../Function/Type)

in  let EitherT = ./Type

in  let Either = ./../Either/Type

in    λ(a : Type)
    → λ(m : Type → Type)
    → λ(monad : Monad m)
    →     ./functor/endo/set
          a
          m
          ( ./../Monad/extractEndofunctor
            Type
            (./../uncurryT Type Type Type ./../Function/Type)
            m
            monad
          )
        ∧ { identity =
                λ(i : Type)
              → λ(x : i)
              → monad.identity (Either a i) < Right = x | Left : a >
          , op =
                  let bind =
                          λ(b : Type)
                        → λ(c : Type)
                        → λ(k : b → EitherT a m c)
                        → ( ./../Monad/terms.dhall
                            Type
                            (./../uncurryT Type Type Type ./../Function/Type)
                            ./../Function/semigroupoid
                            m
                            monad
                          ).bind
                          (Either a b)
                          (Either a c)
                          (   λ(either : Either a b)
                            → merge
                              { Left =
                                    λ(l : a)
                                  → monad.identity
                                    (Either a c)
                                    < Left = l | Right : c >
                              , Right =
                                  k
                              }
                              either
                          )
              
              in    λ(b : Type)
                  → bind
                    (EitherT a m b)
                    b
                    ((./../Function/category).identity (EitherT a m b))
          }
      : Monad (EitherT a m)
