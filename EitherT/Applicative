    let Applicative = ../Applicative/Type 

in  let EitherT = ./Type 

in  let Either = ../Either/Type 

in  let EitherA = ../Either/Applicative 

in  let liftA2 = ../Applicative/liftA2 

in  let toFunctor = ../Functor/fromApplicative 

in    λ(a : Type)
    → λ(m : Type → Type)
    → λ(applicative : Applicative m)
    → (   { map =
              (./Functor  a m (toFunctor m applicative)).map
          , ap =
                λ(b : Type)
              → λ(c : Type)
              → λ(g : EitherT a m (b → c))
              → λ(fa : EitherT a m b)
              → liftA2
                m
                applicative
                (Either a (b → c))
                (Either a b)
                (Either a c)
                ((EitherA a).ap b c)
                g
                fa
          , pure =
                λ(b : Type)
              → λ(x : b)
              → applicative.pure (Either a b) < Right = x | Left : a >
          }
        : Applicative (EitherT a m)
      )
