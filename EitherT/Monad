    let Monad = ../Monad/Type 

in  let EitherT = ./Type 

in  let Either = ../Either/Type 

in  let EitherM = ../Either/Monad 

in  let fold = ../Either/fold 

in  let toFunctor = ../Functor/fromMonad 

in  let toApplicative = ../Applicative/fromMonad 

in    λ(a : Type)
    → λ(m : Type → Type)
    → λ(monad : Monad m)
    → (   { map =
              (./Functor  a m (toFunctor m monad)).map
          , pure =
              (./Applicative  a m (toApplicative m monad)).pure
          , ap =
              (./Applicative  a m (toApplicative m monad)).ap
          , bind =
                λ(b : Type)
              → λ(c : Type)
              → λ(fa : EitherT a m b)
              → λ(k : b → EitherT a m c)
              → monad.bind
                (Either a b)
                (Either a c)
                fa
                (   λ(either : Either a b)
                  → fold
                    a
                    b
                    (EitherT a m c)
                    (   λ(l : a)
                      → monad.pure (Either a c) < Left = l | Right : c >
                    )
                    (λ(r : b) → k r)
                    either
                )
          }
        : Monad (EitherT a m)
      )
