    let kArrow = ./../Function/Kind

in  let kProduct = ./../Tuple/Kind

in    λ(object : Kind)
    → λ(arrow : kArrow (kProduct object object) Type)
    → λ(product : kArrow (kProduct object object) object)
    → λ ( bifunctor
        : ./../Functor/Bifunctor/Type
          object
          object
          object
          arrow
          arrow
          arrow
          product
        )
    → λ(semigroupoid : ./../Semigroupoid/Type object arrow)
    →     let State = ./Type object arrow product
      
      in    { map =
                  λ(a : { _1 : object, _2 : object })
                → λ(b : { _1 : object, _2 : object })
                → λ ( f
                    : { _1 :
                          { _1 :
                              arrow { _1 = a._1, _2 = b._1 }
                          , _2 :
                              arrow { _1 = b._1, _2 = a._1 }
                          }
                      , _2 :
                          arrow { _1 = a._2, _2 = b._2 }
                      }
                    )
                → λ(st : State a._1 a._2)
                → semigroupoid.op
                  { _1 = b._1, _2 = product { _1 = b._1, _2 = b._2 } }
                  (   λ(r : Type)
                    → λ ( arrowsOut
                        :   ∀(z : object)
                          → arrow
                            { _1 = z, _2 = product { _1 = b._1, _2 = b._2 } }
                          → arrow { _1 = b._1, _2 = z }
                          → r
                        )
                    → arrowsOut
                      a._1
                      ( semigroupoid.op
                        { _1 = a._1, _2 = product { _1 = b._1, _2 = b._2 } }
                        (   λ(r : Type)
                          → λ ( arrowsOut
                              :   ∀(z : object)
                                → arrow
                                  { _1 =
                                      z
                                  , _2 =
                                      product { _1 = b._1, _2 = b._2 }
                                  }
                                → arrow { _1 = a._1, _2 = z }
                                → r
                              )
                          → arrowsOut
                            (product { _1 = a._1, _2 = a._2 })
                            ( bifunctor.map
                              { _1 = a._1, _2 = a._2 }
                              { _1 = b._1, _2 = b._2 }
                              { _1 = f._1._1, _2 = f._2 }
                            )
                            st
                        )
                      )
                      f._1._2
                  )
            }
          : ./../Functor/Bifunctor/Type
            object
            object
            Type
            ( ./../uncurryT
              object
              object
              Type
              (./../Category/Dagger/Type object arrow)
            )
            arrow
            (./../uncurryT Type Type Type ./../Function/Type)
            (./../uncurryT object object Type State)
