{-

Similar to a Functor map over `f` where `b` is constrained to `Either`. This constraint gives
us enough information to partition results into a tuple, where `Left`s match to `_1` and `Right`s
match to `_2`.

`mapEither` can also be seen as a parititioning function.

Examples:

```
    let E = constructors (./Either/Type Natural Natural)

in  ./Compactable/mapEither
    List
    ./List/compactable
    ./List/functor
    Natural
    Natural
    (λ(n : Natural) → if Natural/even n then E.Left n else E.Right n)
    [ 1, 2, 3, 4, 5 ]
= { _1 = [ 2, 4 ], _2 = [ 1, 3, 5 ] }
```

-}
    let Either = ./../Either/Type

in  let compose = (./../Function/category).compose

in  let hush = ./../Either/hush

in  let flipEither = ./../Either/flipEither

in    λ(f : Type → Type)
    → λ(c : ./Type f)
    → λ(a : Type)
    → λ(l : Type)
    → λ(r : Type)
    → λ(k : a → Either l r)
    → λ(fa : f a)
    → { _1 =
          c.mapOptional
          a
          l
          ( compose
            a
            (Either r l)
            (Optional l)
            (hush r l)
            (compose a (Either l r) (Either r l) (flipEither l r) k)
          )
          fa
      , _2 =
          c.mapOptional
          a
          r
          (compose a (Either l r) (Optional r) (hush l r) k)
          fa
      }
