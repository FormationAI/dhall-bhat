{-

When `f` is Traversable we can apply a function that compacts results, via `Optional`, within the Applicative
context while still preserving the semantics of the `traverse`.

Examples:

```
    let Either = ./Either/Type

in  let E = constructors (Either Text (Optional Natural))

in  ./Compactable/traverseOptional
    List
    ./List/compactable
    ./List/traversable
    (Either Text)
    (./Either/applicative/sequential Text)
    Natural
    Natural
    (   λ(x : Natural)
      →       if Natural/isZero x

        then  E.Left "No Zeros Allowed!!"

        else  if Natural/odd x

        then  E.Right (Some x)

        else E.Left "Only Odds!!"
    )
    [ 1, 2, 3, 4, 5 ]
= < Left = "Only Odds!!" | Right : List Natural >
```

```
    let Either = ./Either/Type

in  let E = constructors (Either Text (Optional Natural))

in  ./Compactable/traverseOptional
    List
    ./List/compactable
    ./List/traversable
    (Either Text)
    (./Either/applicative/sequential Text)
    Natural
    Natural
    (   λ(x : Natural)
      →       if Natural/isZero x

        then  E.Left "No Zeros Allowed!!"

        else  if Natural/odd x

        then  E.Right (Some x)

        else E.Left "Only Odds!!"
    )
    [ 0, 1, 2, 3, 4, 5 ]
= < Left = "No Zeros Allowed!!" | Right : List Natural >
```

```
    let Either = ./Either/Type

in  let E = constructors (Either Text (Optional Natural))

in  ./Compactable/traverseOptional
    List
    ./List/compactable
    ./List/traversable
    (Either Text)
    (./Either/applicative/sequential Text)
    Natural
    Natural
    (   λ(x : Natural)
      →       if Natural/isZero x

        then  E.Left "No Zeros Allowed!!"

        else  if Natural/odd x

        then  E.Right (Some x)

        else E.Left "Only Odds!!"
    )
    [ 1, 3, 5 ]
= < Right = [ 1, 3, 5 ] | Left : Text >
```

-}
    let Traversable = ./../Traversable/Type

in  let Applicative = ./../Applicative/Type

in    λ(f : Type → Type)
    → λ(c : ./Type f)
    → λ(traversable : Traversable f)
    → λ(g : Type → Type)
    → λ(applicative : Applicative g)
    → λ(a : Type)
    → λ(b : Type)
    → λ(k : a → g (Optional b))
    → λ(fa : f a)
    → applicative.map
      (f (Optional b))
      (f b)
      (./compact f c b)
      (traversable.traverse g applicative a (Optional b) k fa)
