{-

When `f` is an Applicative we can apply a function that compacts results, via `Optional`, within the Applicative
context while still preserving the semantics of `ap`.

Examples:

```
./Compactable/apOptional
List
./List/compactable
./List/applicative
Natural
Natural
[ λ(n : Natural) → if Natural/even n then Some n else None Natural
, λ(n : Natural) → if Natural/odd n then Some n else None Natural
]
[ 0, 1, 2, 3, 4, 5 ]
= [ 0, 2, 4, 1, 3, 5 ]
```

-}
    let Applicative = ./../Applicative/Type

in    λ(f : Type → Type)
    → λ(c : ./Type f)
    → λ(applicative : Applicative f)
    → λ(a : Type)
    → λ(b : Type)
    → λ(k : f (a → Optional b))
    → λ(fa : f a)
    → ./compact f c b (applicative.ap a (Optional b) k fa)
