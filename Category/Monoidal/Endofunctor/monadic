{- NB: This doesn’t use `Duoidal/extractMultiplicative` because that has a fixed
      `object`.
-}
    let kArrow = ./../../../Function/Kind

in  let kProduct = ./../../../Tuple/Kind

in    λ(object : Kind)
    → λ(arrow : kArrow (kProduct object object) Type)
    →   { arrow =
            ./../../../uncurryT
            (kArrow object object)
            (kArrow object object)
            Type
            (./../../../NaturalTransformation/Type object object arrow)
        , identity =
            ./../../../Identity/Type object
        , op =
            ./../../../uncurryT
            (kArrow object object)
            (kArrow object object)
            (kArrow object object)
            (./../../../Compose/Type object object object)
        }
      : ./../Type kArrow kProduct (kArrow object object)
