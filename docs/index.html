<html>
<head>
<title>dhall-bhat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<h1>dhall-bhat</h1>
<h2 style="background-color: #bbb; width: 100%">.</h2>
<h2 style="background-color: #bbb; width: 100%">./Adjunction</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : dObject → cObject)
→ ∀(g : cObject → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dArrow : dObject → dObject → Type)
→ λ(f : dObject → cObject)
→ λ(g : cObject → dObject)
→ { counit :
      ∀(a : cObject) → cArrow (f (g a)) a
  , leftAdjunct :
      ∀(a : dObject) → ∀(b : cObject) → cArrow (f a) b → dArrow a (g b)
  , rightAdjunct :
      ∀(a : dObject) → ∀(b : cObject) → dArrow a (g b) → cArrow (f a) b
  , unit :
      ∀(a : dObject) → dArrow a (g (f a))
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Algebra</h2>
<h2 style="background-color: #bbb; width: 100%">./Algebra/Associative</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(r : object)
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(r : object)
→ λ(m : object)
→ { op : cat.arrow (cat.product (cat.product m r) m) m }
</pre></dd>
</dl>
<h3>Unital (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(r : object)
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(r : object)
→ λ(m : object)
→ { identity :
      cat.arrow r m
  , op :
      cat.arrow (cat.product (cat.product m r) m) m
  }
</pre></dd>
</dl>
<h3>Functor (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(morphism : object → object → Type)
→ ∀(f : object → object)
→ ∀(a : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(morphism : object → object → Type)
→ λ(f : object → object)
→ λ(a : object)
→ morphism (f a) a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Alternative</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          dObject → dObject → Type
      , identity :
          dObject
      , product :
          dObject → dObject → dObject
      }
    )
→ ∀(f : cObject → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ ( d
    : { arrow :
          dObject → dObject → Type
      , identity :
          dObject
      , product :
          dObject → dObject → dObject
      }
    )
→ λ(f : cObject → dObject)
→   ∀(a : cObject)
  → { identity :
        d.arrow d.identity (f a)
    , op :
        d.arrow (d.product (f a) (f a)) (f a)
    }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Applicative</h2>
<h3>ap (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(a : Type) → a → f a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : f b._1, _2 : f b._2 }
                  → r
                )
              → r
            )
          → f a
      }
    )
→ ∀(a : Type)
→ ∀(b : Type)
→ ∀(fn : f (a → b))
→ ∀(fa : f a)
→ f b
</pre></dd>
</dl>
<h3>fromPureAp (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀(pure : ∀(a : Type) → a → m a)
→ ∀(ap : ∀(a : Type) → ∀(b : Type) → m (a → b) → m a → m b)
→ { identity :
      ∀(a : Type) → a → m a
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(d : { _1 : Type, _2 : Type })
                → ({ _1 : d._1, _2 : d._2 } → i)
                → { _1 : m d._1, _2 : m d._2 }
                → r
              )
            → r
          )
      → m i
  }
</pre></dd>
</dl>
<h3>impliedEndofunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(a : Type) → a → f a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : f b._1, _2 : f b._2 }
                  → r
                )
              → r
            )
          → f a
      }
    )
→ { map : ∀(a : Type) → ∀(b : Type) → ∀(fn : a → b) → ∀(fa : f a) → f b }
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(a : Type) → a → f a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : f b._1, _2 : f b._2 }
                  → r
                )
              → r
            )
          → f a
      }
    )
→ { ap :
      ∀(a : Type) → ∀(b : Type) → ∀(fn : f (a → b)) → ∀(fa : f a) → f b
  , extractFunctor :
      { map : ∀(a : Type) → ∀(b : Type) → ∀(fn : a → b) → ∀(fa : f a) → f b }
  , lift2 :
        ∀(a : Type)
      → (   ∀(r : Type)
          → (   ∀(b : { _1 : Type, _2 : Type })
              → ({ _1 : b._1, _2 : b._2 } → a)
              → { _1 : f b._1, _2 : f b._2 }
              → r
            )
          → r
        )
      → f a
  , map :
      ∀(a : Type) → ∀(b : Type) → ∀(fn : a → b) → ∀(fa : f a) → f b
  , pure :
      ∀(a : Type) → a → f a
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type → Type)
→ { identity :
      ∀(a : Type) → a → m a
  , op :
        ∀(a : Type)
      → (   ∀(r : Type)
          → (   ∀(b : { _1 : Type, _2 : Type })
              → ({ _1 : b._1, _2 : b._2 } → a)
              → { _1 : m b._1, _2 : m b._2 }
              → r
            )
          → r
        )
      → m a
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Arrow</h2>
<h3>extractCategory (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type → Type)
→ ∀ ( arrow
    : { arr :
          ∀(a : Type) → ∀(b : Type) → (a → b) → f a b
      , fanout :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → f a b
          → f a c
          → f a { _1 : b, _2 : c }
      , identity :
          ∀(a : Type) → f a a
      , lmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → a) → f a c → f b c
      , map :
            ∀(a : { _1 : Type, _2 : Type })
          → ∀(b : { _1 : Type, _2 : Type })
          → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
          → f a._1 a._2
          → f b._1 b._2
      , op :
            ∀(a : Type)
          → ∀(b : Type)
          → (∀(r : Type) → (∀(z : Type) → f z b → f a z → r) → r)
          → f a b
      , rmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
      , split :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → ∀(d : Type)
          → f a b
          → f c d
          → f { _1 : a, _2 : c } { _1 : b, _2 : d }
      }
    )
→ { identity :
      ∀(a : Type) → f a a
  , op :
        ∀(a : Type)
      → ∀(b : Type)
      → (∀(r : Type) → (∀(z : Type) → f z b → f a z → r) → r)
      → f a b
  }
</pre></dd>
</dl>
<h3>extractProfunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type → Type)
→ ∀ ( arrow
    : { arr :
          ∀(a : Type) → ∀(b : Type) → (a → b) → f a b
      , fanout :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → f a b
          → f a c
          → f a { _1 : b, _2 : c }
      , identity :
          ∀(a : Type) → f a a
      , lmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → a) → f a c → f b c
      , map :
            ∀(a : { _1 : Type, _2 : Type })
          → ∀(b : { _1 : Type, _2 : Type })
          → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
          → f a._1 a._2
          → f b._1 b._2
      , op :
            ∀(a : Type)
          → ∀(b : Type)
          → (∀(r : Type) → (∀(z : Type) → f z b → f a z → r) → r)
          → f a b
      , rmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
      , split :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → ∀(d : Type)
          → f a b
          → f c d
          → f { _1 : a, _2 : c } { _1 : b, _2 : d }
      }
    )
→ { map :
        ∀(a : { _1 : Type, _2 : Type })
      → ∀(b : { _1 : Type, _2 : Type })
      → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
      → f a._1 a._2
      → f b._1 b._2
  }
</pre></dd>
</dl>
<h3>extractSemigroupoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type → Type)
→ ∀ ( arrow
    : { arr :
          ∀(a : Type) → ∀(b : Type) → (a → b) → f a b
      , fanout :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → f a b
          → f a c
          → f a { _1 : b, _2 : c }
      , identity :
          ∀(a : Type) → f a a
      , lmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → a) → f a c → f b c
      , map :
            ∀(a : { _1 : Type, _2 : Type })
          → ∀(b : { _1 : Type, _2 : Type })
          → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
          → f a._1 a._2
          → f b._1 b._2
      , op :
            ∀(a : Type)
          → ∀(b : Type)
          → (∀(r : Type) → (∀(z : Type) → f z b → f a z → r) → r)
          → f a b
      , rmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
      , split :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → ∀(d : Type)
          → f a b
          → f c d
          → f { _1 : a, _2 : c } { _1 : b, _2 : d }
      }
    )
→ { op :
        ∀(a : Type)
      → ∀(b : Type)
      → (∀(r : Type) → (∀(z : Type) → f z b → f a z → r) → r)
      → f a b
  }
</pre></dd>
</dl>
<h3>extractStrong (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type → Type)
→ ∀ ( arrow
    : { arr :
          ∀(a : Type) → ∀(b : Type) → (a → b) → f a b
      , fanout :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → f a b
          → f a c
          → f a { _1 : b, _2 : c }
      , identity :
          ∀(a : Type) → f a a
      , lmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → a) → f a c → f b c
      , map :
            ∀(a : { _1 : Type, _2 : Type })
          → ∀(b : { _1 : Type, _2 : Type })
          → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
          → f a._1 a._2
          → f b._1 b._2
      , op :
            ∀(a : Type)
          → ∀(b : Type)
          → (∀(r : Type) → (∀(z : Type) → f z b → f a z → r) → r)
          → f a b
      , rmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
      , split :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → ∀(d : Type)
          → f a b
          → f c d
          → f { _1 : a, _2 : c } { _1 : b, _2 : d }
      }
    )
→ { lmap :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → a) → f a c → f b c
  , map :
        ∀(a : { _1 : Type, _2 : Type })
      → ∀(b : { _1 : Type, _2 : Type })
      → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
      → f a._1 a._2
      → f b._1 b._2
  , rmap :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(f : Type → Type → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(f : Type → Type → Type)
→ { arr :
      ∀(a : Type) → ∀(b : Type) → (a → b) → f a b
  , fanout :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(c : Type)
      → f a b
      → f a c
      → f a { _1 : b, _2 : c }
  , identity :
      ∀(a : Type) → f a a
  , lmap :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → a) → f a c → f b c
  , map :
        ∀(a : { _1 : Type, _2 : Type })
      → ∀(b : { _1 : Type, _2 : Type })
      → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
      → f a._1 a._2
      → f b._1 b._2
  , op :
        ∀(a : Type)
      → ∀(b : Type)
      → (∀(r : Type) → (∀(z : Type) → f z b → f a z → r) → r)
      → f a b
  , rmap :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
  , split :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(c : Type)
      → ∀(d : Type)
      → f a b
      → f c d
      → f { _1 : a, _2 : c } { _1 : b, _2 : d }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Bool</h2>
<h3>eq (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ eq : ∀(x : Bool) → ∀(y : Bool) → Bool }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Bool/monoid</h2>
<h3>conjunction (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity : {} → Bool, op : ∀(p : { _1 : Bool, _2 : Bool }) → Bool }
</pre></dd>
</dl>
<h3>disjunction (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity : {} → Bool, op : ∀(p : { _1 : Bool, _2 : Bool }) → Bool }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category</h2>
<h2 style="background-color: #bbb; width: 100%">./Category/Cone</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category/Dagger</h2>
<h3>category (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { identity :
          ∀(a : object) → arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ { identity :
      ∀(a : object) → { _1 : arrow a a, _2 : arrow a a }
  , op :
        ∀(a : object)
      → ∀(b : object)
      → ∀ ( p
          :   ∀(r : Type)
            → (   ∀(z : object)
                → { _1 : arrow z b, _2 : arrow b z }
                → { _1 : arrow a z, _2 : arrow z a }
                → r
              )
            → r
          )
      → { _1 : arrow a b, _2 : arrow b a }
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(a : object)
→ ∀(b : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(a : object)
→ λ(b : object)
→ { _1 : arrow a b, _2 : arrow b a }
</pre></dd>
</dl>
<h3>Enriched (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(vObject : Kind) → ∀(cObject : Kind) → Kind
</pre></dd>
</dl>
<h3>extractSemigroupoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { identity :
          ∀(a : object) → arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ { op :
        ∀(a : object)
      → ∀(b : object)
      → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
      → arrow a b
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category/Monoidal</h2>
<h3>Profunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(morphism : object → object → Type)
→ { arrow :
      ∀(p : object → object → Type) → ∀(q : object → object → Type) → Type
  , identity :
      object → object → Type
  , product :
        ∀(p : object → object → Type)
      → ∀(q : object → object → Type)
      → ∀(a : object)
      → ∀(b : object)
      → Type
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category/Monoidal/Set</h2>
<h3>cartesian (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ arrow :
    ∀(a : Type) → ∀(b : Type) → Type
, identity :
    Type
, product :
    ∀(a : Type) → ∀(b : Type) → Type
}
</pre></dd>
</dl>
<h3>cocartesian (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ arrow :
    ∀(a : Type) → ∀(b : Type) → Type
, identity :
    Type
, product :
    ∀(a : Type) → ∀(b : Type) → Type
}
</pre></dd>
</dl>
<h3>Type (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(object : Kind) → Kind
</pre></dd>
</dl>
<h3>types.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ { Adjunction :
      ∀(f : object → object) → ∀(g : object → object) → Type
  , Applicative :
      ∀(m : Type → Type) → Type
  , Arrow :
      ∀(f : Type → Type → Type) → Type
  , Bifunctor :
      ∀(f : object → object → object) → Type
  , Category :
      ∀(morphism : object → object → Type) → Type
  , Codensity :
      ∀(dArrow : Type → Type → Type) → ∀(m : object → Type) → ∀(a : Type) → Type
  , CommutativeGroup :
      ∀(m : object) → Type
  , CommutativeMonoid :
      ∀(m : object) → Type
  , Comonad :
      ∀(m : object → object) → Type
  , Compactable :
      ∀(f : Type → Type) → Type
  , Compose :
      ∀(f : object → object) → ∀(g : object → object) → ∀(a : object) → object
  , Const :
      ∀(a : object) → object → object
  , Costar :
      ∀(m : object → object) → ∀(a : object) → ∀(b : object) → Type
  , Coyoneda :
      ∀(f : object → Type) → ∀(a : object) → Type
  , Day :
        ∀ ( v
          : { arrow :
                Type → Type → Type
            , identity :
                Type
            , product :
                Type → Type → Type
            }
          )
      → ∀(f : object → Type)
      → ∀(g : object → Type)
      → ∀(a : object)
      → Type
  , Density :
      ∀(f : object → Type) → ∀(a : Type) → Type
  , DifferenceList :
      ∀(a : Type) → Type
  , Either :
      ∀(a : Type) → ∀(b : Type) → Type
  , EitherT :
      ∀(a : Type) → ∀(m : Type → Type) → ∀(b : Type) → Type
  , Endofunctor :
      ∀(f : object → object) → Type
  , Eq :
      ∀(a : Type) → Type
  , Field :
      ∀(m : object) → Type
  , Function :
      ∀(a : Type) → ∀(b : Type) → Type
  , Group :
      ∀(m : object) → Type
  , HomFunctor :
      ∀(f : object → object → Type) → Type
  , Identity :
      ∀(a : object) → object
  , InternalHomFunctor :
      ∀(arrow : object → object → Type) → ∀(f : object → object → object) → Type
  , Lan :
      ∀(p : object → object) → ∀(f : object → Type) → ∀(a : object) → Type
  , Leibniz :
      ∀(a : object) → ∀(b : object) → Type
  , Monad :
      ∀(m : object → object) → Type
  , Monoid :
      ∀(m : object) → Type
  , NaturalTransformation :
      ∀(f : object → object) → ∀(g : object → object) → Type
  , NonEmptyList :
      ∀(a : Type) → Type
  , OrderedField :
      ∀(m : Type) → Type
  , OrderedGroup :
      ∀(m : Type) → Type
  , OrderedRing :
      ∀(m : Type) → Type
  , PartiallyOrderedField :
      ∀(m : Type) → Type
  , PartiallyOrderedGroup :
      ∀(m : Type) → Type
  , PartiallyOrderedRing :
      ∀(m : Type) → Type
  , Profunctor :
      ∀(f : object → object → Type) → Type
  , Ran :
      ∀(p : object → object) → ∀(f : object → Type) → ∀(a : object) → Type
  , Reader :
      ∀(r : object) → ∀(a : object) → Type
  , ReaderT :
      ∀(m : object → object) → ∀(r : object) → ∀(a : object) → Type
  , Rig :
      ∀(m : object) → Type
  , Ring :
      ∀(m : object) → Type
  , Semigroup :
      ∀(m : object) → Type
  , Semigroupoid :
      ∀(m : object → object → Type) → Type
  , Semiring :
      ∀(m : object) → Type
  , Star :
      ∀(m : object → object) → ∀(a : object) → ∀(b : object) → Type
  , State :
      ∀(s : object) → ∀(a : object) → Type
  , StateT :
      ∀(m : object → object) → ∀(s : object) → ∀(a : object) → Type
  , Strong :
      ∀(f : object → object → Type) → Type
  , Transformer :
      ∀(t : (object → object) → object → object) → Type
  , Traversable :
      ∀(m : object → object) → ∀(f : object → object) → Type
  , Tuple :
      ∀(a : Type) → ∀(b : Type) → Type
  , Yoneda :
      ∀(f : object → Type) → ∀(a : object) → Type
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category/Op</h2>
<h3>category (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { identity :
          ∀(a : object) → arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ { identity :
      ∀(a : object) → arrow a a
  , op :
        ∀(a : object)
      → ∀(b : object)
      → ∀(p : ∀(r : Type) → (∀(z : object) → arrow b z → arrow z a → r) → r)
      → arrow b a
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(a : object)
→ ∀(b : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(a : object)
→ λ(b : object)
→ arrow b a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category/Product</h2>
<h3>category (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀ ( cCategory
    : { identity :
          ∀(a : cObject) → cArrow a a
      , op :
            ∀(a : cObject)
          → ∀(b : cObject)
          → (∀(r : Type) → (∀(z : cObject) → cArrow z b → cArrow a z → r) → r)
          → cArrow a b
      }
    )
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀ ( dCategory
    : { identity :
          ∀(a : dObject) → dArrow a a
      , op :
            ∀(a : dObject)
          → ∀(b : dObject)
          → (∀(r : Type) → (∀(z : dObject) → dArrow z b → dArrow a z → r) → r)
          → dArrow a b
      }
    )
→ { identity :
        ∀(a : { _1 : cObject, _2 : dObject })
      → { _1 : cArrow a._1 a._1, _2 : dArrow a._2 a._2 }
  , op :
        ∀(a : { _1 : cObject, _2 : dObject })
      → ∀(b : { _1 : cObject, _2 : dObject })
      → ∀ ( p
          :   ∀(r : Type)
            → (   ∀(z : { _1 : cObject, _2 : dObject })
                → { _1 : cArrow z._1 b._1, _2 : dArrow z._2 b._2 }
                → { _1 : cArrow a._1 z._1, _2 : dArrow a._2 z._2 }
                → r
              )
            → r
          )
      → { _1 : cArrow a._1 b._1, _2 : dArrow a._2 b._2 }
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(a : { _1 : cObject, _2 : dObject })
→ ∀(b : { _1 : cObject, _2 : dObject })
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dArrow : dObject → dObject → Type)
→ λ(a : { _1 : cObject, _2 : dObject })
→ λ(b : { _1 : cObject, _2 : dObject })
→ { _1 : cArrow a._1 b._1, _2 : dArrow a._2 b._2 }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category/Set</h2>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ applicative :
      ∀(f : Type → Type)
    → ∀ ( applicative
        : { identity :
              ∀(a : Type) → a → f a
          , op :
                ∀(a : Type)
              → (   ∀(r : Type)
                  → (   ∀(b : { _1 : Type, _2 : Type })
                      → ({ _1 : b._1, _2 : b._2 } → a)
                      → { _1 : f b._1, _2 : f b._2 }
                      → r
                    )
                  → r
                )
              → f a
          }
        )
    → { ap :
          ∀(a : Type) → ∀(b : Type) → ∀(fn : f (a → b)) → ∀(fa : f a) → f b
      , extractFunctor :
          { map :
              ∀(a : Type) → ∀(b : Type) → ∀(fn : a → b) → ∀(fa : f a) → f b
          }
      , lift2 :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : f b._1, _2 : f b._2 }
                  → r
                )
              → r
            )
          → f a
      , map :
          ∀(a : Type) → ∀(b : Type) → ∀(fn : a → b) → ∀(fa : f a) → f b
      , pure :
          ∀(a : Type) → a → f a
      }
, either :
    { a :
          ∀(a : Type)
        → { bind :
                ∀(a : Type)
              → ∀(b : Type)
              → ∀(f : a → < Left : a@1 | Right : b >)
              → ∀(x : < Left : a@1 | Right : a >)
              → < Left : a@1 | Right : b >
          , extractEndofunctor :
              { map :
                    ∀(a : Type)
                  → ∀(b : Type)
                  → ∀(fn : a → b)
                  → ∀(fa : < Left : a@1 | Right : a >)
                  → < Left : a@1 | Right : b >
              }
          , extractStarfunctor :
              { map :
                    ∀(a : Type)
                  → ∀(b : Type)
                  → ∀(f : a → < Left : a@1 | Right : b >)
                  → ∀(x : < Left : a@1 | Right : a >)
                  → < Left : a@1 | Right : b >
              }
          , join :
                ∀(a : Type)
              → ∀(fa : < Left : a@1 | Right : < Left : a@1 | Right : a > >)
              → < Left : a@1 | Right : a >
          , map :
                ∀(a : Type)
              → ∀(b : Type)
              → ∀(fn : a → b)
              → ∀(fa : < Left : a@1 | Right : a >)
              → < Left : a@1 | Right : b >
          , pure :
              ∀(b : Type) → ∀(x : b) → < Left : a | Right : b >
          }
    , ab :
          ∀(a : Type)
        → ∀(b : Type)
        → { Left :
              ∀(Left : a) → < Left : a | Right : b >
          , Right :
              ∀(Right : b) → < Left : a | Right : b >
          , fromLeft :
              ∀(def : a) → ∀(e : < Left : a | Right : b >) → a
          , fromRight :
              ∀(def : b) → ∀(e : < Left : a | Right : b >) → b
          , isLeft :
              ∀(e : < Left : a | Right : b >) → Bool
          , isRight :
              ∀(e : < Left : a | Right : b >) → Bool
          , lefts :
              ∀(eithers : List < Left : a | Right : b >) → List a
          , partition :
                ∀(eithers : List < Left : a | Right : b >)
              → { lefts : List a, rights : List b }
          , rights :
              ∀(eithers : List < Left : a | Right : b >) → List b
          }
    , pair :
        { map :
              ∀(a : { _1 : Type, _2 : Type })
            → ∀(b : { _1 : Type, _2 : Type })
            → ∀(f : { _1 : a._1 → b._1, _2 : a._2 → b._2 })
            → ∀(e : < Left : a._1 | Right : a._2 >)
            → < Left : b._1 | Right : b._2 >
        }
    , traverse :
          ∀(m : Type → Type)
        → ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b })
        → { map :
                ∀(a : { _1 : Type, _2 : Type })
              → ∀(b : { _1 : Type, _2 : Type })
              → ∀(f : { _1 : a._1 → m b._1, _2 : a._2 → m b._2 })
              → ∀(e : < Left : a._1 | Right : a._2 >)
              → m < Left : b._1 | Right : b._2 >
          }
    }
, functor :
      ∀(f : Type → Type)
    → ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → f a → f b })
    → { map : ∀(a : Type) → ∀(b : Type) → (a → b) → f a → f b }
, monad :
      ∀(m : Type → Type)
    → ∀ ( monad
        : { identity :
              ∀(a : Type) → a → m a
          , map :
              ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b
          , op :
              ∀(a : Type) → m (m a) → m a
          }
        )
    → { bind :
          ∀(a : Type) → ∀(b : Type) → ∀(f : a → m b) → ∀(x : m a) → m b
      , extractEndofunctor :
          { map : ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b }
      , extractStarfunctor :
          { map :
              ∀(a : Type) → ∀(b : Type) → ∀(f : a → m b) → ∀(x : m a) → m b
          }
      , join :
          ∀(a : Type) → m (m a) → m a
      , map :
          ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b
      , pure :
          ∀(a : Type) → a → m a
      }
, reader :
      ∀(r : Type)
    → { bind :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(f : a → r → b)
          → ∀(x : r → a)
          → ∀(env : r)
          → b
      , extractEndofunctor :
          { map :
                ∀(a : Type)
              → ∀(b : Type)
              → ∀(fn : a → b)
              → ∀(fa : r → a)
              → ∀(env : r)
              → b
          }
      , extractStarfunctor :
          { map :
                ∀(a : Type)
              → ∀(b : Type)
              → ∀(f : a → r → b)
              → ∀(x : r → a)
              → ∀(env : r)
              → b
          }
      , join :
          ∀(a : Type) → ∀(fa : r → r → a) → ∀(env : r) → a
      , map :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(fn : a → b)
          → ∀(fa : r → a)
          → ∀(env : r)
          → b
      , pure :
          ∀(a : Type) → ∀(x : a) → r → a
      , withReader :
            ∀(a : Type)
          → ∀(ePrime : Type)
          → ∀(f : ePrime → r)
          → ∀(reader : r → a)
          → ∀(x : ePrime)
          → a
      }
}
</pre></dd>
</dl>
<h3>types.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ Adjunction :
    ∀(f : Type → Type) → ∀(g : Type → Type) → Type
, Applicative :
    ∀(m : Type → Type) → Type
, Arrow :
    ∀(f : Type → Type → Type) → Type
, Bifunctor :
    ∀(f : Type → Type → Type) → Type
, Category :
    ∀(morphism : Type → Type → Type) → Type
, Codensity :
    ∀(dArrow : Type → Type → Type) → ∀(m : Type → Type) → ∀(a : Type) → Type
, CommutativeGroup :
    ∀(m : Type) → Type
, CommutativeMonoid :
    ∀(m : Type) → Type
, Comonad :
    ∀(m : Type → Type) → Type
, Compactable :
    ∀(f : Type → Type) → Type
, Compose :
    ∀(f : Type → Type) → ∀(g : Type → Type) → ∀(a : Type) → Type
, Const :
    ∀(a : Type) → Type → Type
, Costar :
    ∀(m : Type → Type) → ∀(a : Type) → ∀(b : Type) → Type
, Coyoneda :
    ∀(f : Type → Type) → ∀(a : Type) → Type
, Day :
      ∀ ( v
        : { arrow :
              Type → Type → Type
          , identity :
              Type
          , product :
              Type → Type → Type
          }
        )
    → ∀(f : Type → Type)
    → ∀(g : Type → Type)
    → ∀(a : Type)
    → Type
, Density :
    ∀(f : Type → Type) → ∀(a : Type) → Type
, DifferenceList :
    ∀(a : Type) → Type
, Either :
    ∀(a : Type) → ∀(b : Type) → Type
, EitherT :
    ∀(a : Type) → ∀(m : Type → Type) → ∀(b : Type) → Type
, Endofunctor :
    ∀(f : Type → Type) → Type
, Eq :
    ∀(a : Type) → Type
, Field :
    ∀(m : Type) → Type
, Function :
    ∀(a : Type) → ∀(b : Type) → Type
, Group :
    ∀(m : Type) → Type
, HomFunctor :
    ∀(f : Type → Type → Type) → Type
, Identity :
    ∀(a : Type) → Type
, InternalHomFunctor :
    ∀(arrow : Type → Type → Type) → ∀(f : Type → Type → Type) → Type
, Lan :
    ∀(p : Type → Type) → ∀(f : Type → Type) → ∀(a : Type) → Type
, Leibniz :
    ∀(a : Type) → ∀(b : Type) → Type
, Monad :
    ∀(m : Type → Type) → Type
, Monoid :
    ∀(m : Type) → Type
, NaturalTransformation :
    ∀(f : Type → Type) → ∀(g : Type → Type) → Type
, NonEmptyList :
    ∀(a : Type) → Type
, OrderedField :
    ∀(m : Type) → Type
, OrderedGroup :
    ∀(m : Type) → Type
, OrderedRing :
    ∀(m : Type) → Type
, PartiallyOrderedField :
    ∀(m : Type) → Type
, PartiallyOrderedGroup :
    ∀(m : Type) → Type
, PartiallyOrderedRing :
    ∀(m : Type) → Type
, Profunctor :
    ∀(f : Type → Type → Type) → Type
, Ran :
    ∀(p : Type → Type) → ∀(f : Type → Type) → ∀(a : Type) → Type
, Reader :
    ∀(r : Type) → ∀(a : Type) → Type
, ReaderT :
    ∀(m : Type → Type) → ∀(r : Type) → ∀(a : Type) → Type
, Rig :
    ∀(m : Type) → Type
, Ring :
    ∀(m : Type) → Type
, Semigroup :
    ∀(m : Type) → Type
, Semigroupoid :
    ∀(m : Type → Type → Type) → Type
, Semiring :
    ∀(m : Type) → Type
, Star :
    ∀(m : Type → Type) → ∀(a : Type) → ∀(b : Type) → Type
, State :
    ∀(s : Type) → ∀(a : Type) → Type
, StateT :
    ∀(m : Type → Type) → ∀(s : Type) → ∀(a : Type) → Type
, Strong :
    ∀(f : Type → Type → Type) → Type
, Transformer :
    ∀(t : (Type → Type) → Type → Type) → Type
, Traversable :
    ∀(m : Type → Type) → ∀(f : Type → Type) → Type
, Tuple :
    ∀(a : Type) → ∀(b : Type) → Type
, Yoneda :
    ∀(f : Type → Type) → ∀(a : Type) → Type
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category/Sub</h2>
<h3>category (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(object : Kind) → ∀(morphism : object → object → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(morphism : object → object → Type)
→ { identity :
      ∀(a : object) → morphism a a
  , op :
        ∀(a : object)
      → ∀(b : object)
      → (∀(r : Type) → (∀(z : object) → morphism z b → morphism a z → r) → r)
      → morphism a b
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Cell</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Codensity</h2>
<h3>applicative (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ { identity :
      ∀(a : Type) → ∀(x : a) → ∀(b : Type) → ∀(k : a → m b) → m b
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(d : { _1 : Type, _2 : Type })
                → ({ _1 : d._1, _2 : d._2 } → i)
                → { _1 :
                      ∀(b : Type) → (d._1 → m b) → m b
                  , _2 :
                      ∀(b : Type) → (d._2 → m b) → m b
                  }
                → r
              )
            → r
          )
      → ∀(b : Type)
      → (i → m b)
      → m b
  }
</pre></dd>
</dl>
<h3>functor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(arrow : Type → Type → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : Type)
          → ∀(b : Type)
          → (∀(r : Type) → (∀(z : Type) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(m : Type → Type)
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(fn : arrow a b)
      → ∀(ran : ∀(b : Type) → arrow a (m b) → m b)
      → ∀(c : Type)
      → ∀(k : arrow b (m c))
      → m c
  }
</pre></dd>
</dl>
<h3>lift (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(f : object → object)
→ ∀ ( monad
    : { identity :
          ∀(a : object) → arrow a (f a)
      , map :
          ∀(a : object) → ∀(b : object) → arrow a b → arrow (f a) (f b)
      , op :
          ∀(a : object) → arrow (f (f a)) (f a)
      }
    )
→ ∀(a : object)
→ ∀(b : object)
→ ∀(k : arrow a (f b))
→ arrow (f a) (f b)
</pre></dd>
</dl>
<h3>lower (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(a : Type) → a → m a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : m b._1, _2 : m b._2 }
                  → r
                )
              → r
            )
          → m a
      }
    )
→ ∀(a : Type)
→ ∀(ran : ∀(b : Type) → (a → m b) → m b)
→ m a
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀ ( category
    : { identity :
          ∀(a : Type) → a → a
      , op :
            ∀(a : Type)
          → ∀(b : Type)
          → (∀(r : Type) → (∀(z : Type) → (z → b) → (a → z) → r) → r)
          → a
          → b
      }
    )
→ ∀(m : Type → Type)
→ { identity :
      ∀(a : Type) → ∀(x : a) → ∀(b : Type) → ∀(k : a → m b) → m b
  , map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(fn : a → b)
      → ∀(codensity : ∀(b : Type) → (a → m b) → m b)
      → ∀(c : Type)
      → ∀(l : b → m c)
      → m c
  , op :
        ∀(a : Type)
      → ∀ ( codensity
          : ∀(b : Type) → ((∀(b : Type) → (a → m b) → m b) → m b) → m b
          )
      → ∀(c : Type)
      → ∀(l : a → m c)
      → m c
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dArrow : Type → Type → Type)
→ ∀(m : cObject → Type)
→ ∀(a : Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dArrow : Type → Type → Type)
→ λ(m : cObject → Type)
→ λ(a : Type)
→ ∀(b : cObject) → dArrow a (m b) → m b
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Comonad</h2>
<h3>extractEndofunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(w : object → object)
→ ∀ ( comonad
    : { identity :
          ∀(a : object) → arrow (w a) a
      , map :
          ∀(a : object) → ∀(b : object) → arrow b a → arrow (w b) (w a)
      , op :
          ∀(a : object) → arrow (w a) (w (w a))
      }
    )
→ { map : ∀(a : object) → ∀(b : object) → arrow a b → arrow (w a) (w b) }
</pre></dd>
</dl>
<h3>fromExtractExtend (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { identity :
          ∀(a : object) → arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(f : object → object)
→ ∀(pure : ∀(a : object) → arrow (f a) a)
→ ∀(bind : ∀(a : object) → ∀(b : object) → arrow (f b) a → arrow (f b) (f a))
→ { identity :
      ∀(a : object) → arrow (f a) a
  , map :
      ∀(a : object) → ∀(b : object) → ∀(fn : arrow b a) → arrow (f b) (f a)
  , op :
      ∀(a : object) → arrow (f a) (f (f a))
  }
</pre></dd>
</dl>
<h3>impliedCostarfunctor (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ { identity :
      ∀(a : object) → arrow (m a) a
  , map :
      ∀(a : object) → ∀(b : object) → arrow b a → arrow (m b) (m a)
  , op :
      ∀(a : object) → arrow (m a) (m (m a))
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Compose</h2>
<h3>applicative (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( fApplicative
    : { identity :
          ∀(a : Type) → a → f a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : f b._1, _2 : f b._2 }
                  → r
                )
              → r
            )
          → f a
      }
    )
→ ∀(g : Type → Type)
→ ∀ ( gApplicative
    : { identity :
          ∀(a : Type) → a → g a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : g b._1, _2 : g b._2 }
                  → r
                )
              → r
            )
          → g a
      }
    )
→ { identity :
      ∀(a : Type) → ∀(x : a) → f (g a)
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : { _1 : Type, _2 : Type })
                → ({ _1 : b._1, _2 : b._2 } → i)
                → { _1 : f (g b._1), _2 : f (g b._2) }
                → r
              )
            → r
          )
      → f (g i)
  }
</pre></dd>
</dl>
<h3>comonad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : dObject → cObject)
→ ∀ ( fFunctor
    : { map :
          ∀(a : dObject) → ∀(b : dObject) → dArrow a b → cArrow (f a) (f b)
      }
    )
→ ∀(g : cObject → dObject)
→ ∀ ( gFunctor
    : { map :
          ∀(a : cObject) → ∀(b : cObject) → cArrow a b → dArrow (g a) (g b)
      }
    )
→ ∀ ( adjunction
    : { counit :
          ∀(a : cObject) → cArrow (f (g a)) a
      , leftAdjunct :
          ∀(a : dObject) → ∀(b : cObject) → cArrow (f a) b → dArrow a (g b)
      , rightAdjunct :
          ∀(a : dObject) → ∀(b : cObject) → dArrow a (g b) → cArrow (f a) b
      , unit :
          ∀(a : dObject) → dArrow a (g (f a))
      }
    )
→ { identity :
      ∀(a : cObject) → cArrow (f (g a)) a
  , map :
        ∀(b : cObject)
      → ∀(a : cObject)
      → ∀(fn : cArrow a b)
      → cArrow (f (g a)) (f (g b))
  , op :
      ∀(a : cObject) → cArrow (f (g a)) (f (g (f (g a))))
  }
</pre></dd>
</dl>
<h3>foldable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( fFoldable
    : { fold : ∀(a : Type) → ∀(b : Type) → (b → a → b) → b → f a → b }
    )
→ ∀(g : Type → Type)
→ ∀ ( gFoldable
    : { fold : ∀(a : Type) → ∀(b : Type) → (b → a → b) → b → g a → b }
    )
→ { fold :
      ∀(a : Type) → ∀(b : Type) → ∀(k : b → a → b) → ∀(z : b) → f (g a) → b
  }
</pre></dd>
</dl>
<h3>functor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(eObject : Kind)
→ ∀(eArrow : eObject → eObject → Type)
→ ∀(f : dObject → eObject)
→ ∀ ( fFunctor
    : { map :
          ∀(a : dObject) → ∀(b : dObject) → dArrow a b → eArrow (f a) (f b)
      }
    )
→ ∀(g : cObject → dObject)
→ ∀ ( gFunctor
    : { map :
          ∀(a : cObject) → ∀(b : cObject) → cArrow a b → dArrow (g a) (g b)
      }
    )
→ { map :
        ∀(a : cObject)
      → ∀(b : cObject)
      → ∀(k : cArrow a b)
      → eArrow (f (g a)) (f (g b))
  }
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : dObject → cObject)
→ ∀ ( fFunctor
    : { map :
          ∀(a : dObject) → ∀(b : dObject) → dArrow a b → cArrow (f a) (f b)
      }
    )
→ ∀(g : cObject → dObject)
→ ∀ ( gFunctor
    : { map :
          ∀(a : cObject) → ∀(b : cObject) → cArrow a b → dArrow (g a) (g b)
      }
    )
→ ∀ ( adjunction
    : { counit :
          ∀(a : cObject) → cArrow (f (g a)) a
      , leftAdjunct :
          ∀(a : dObject) → ∀(b : cObject) → cArrow (f a) b → dArrow a (g b)
      , rightAdjunct :
          ∀(a : dObject) → ∀(b : cObject) → dArrow a (g b) → cArrow (f a) b
      , unit :
          ∀(a : dObject) → dArrow a (g (f a))
      }
    )
→ { identity :
      ∀(a : dObject) → dArrow a (g (f a))
  , map :
        ∀(a : dObject)
      → ∀(b : dObject)
      → ∀(fn : dArrow a b)
      → dArrow (g (f a)) (g (f b))
  , op :
      ∀(a : dObject) → dArrow (g (f (g (f a)))) (g (f a))
  }
</pre></dd>
</dl>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(f : Type → Type) → ∀(g : Type → Type) → ∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(f : Type → Type) → λ(g : Type → Type) → λ(a : Type) → f (g a)
</pre></dd>
</dl>
<h3>Type (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(eObject : Kind)
→ ∀(f : dObject → eObject)
→ ∀(g : cObject → dObject)
→ ∀(a : cObject)
→ eObject
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Cone</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(indexObject : Kind)
→ ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : indexObject → object)
→ ∀(n : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(indexObject : Kind)
→ λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(f : indexObject → object)
→ λ(n : object)
→ ∀(x : indexObject) → arrow n (f x)
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Const</h2>
<h3>functor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀ ( cCategory
    : { identity :
          ∀(a : cObject) → cArrow a a
      , op :
            ∀(a : cObject)
          → ∀(b : cObject)
          → (∀(r : Type) → (∀(z : cObject) → cArrow z b → cArrow a z → r) → r)
          → cArrow a b
      }
    )
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(a : cObject)
→ { map : ∀(b : dObject) → ∀(c : dObject) → dArrow b c → cArrow a a }
</pre></dd>
</dl>
<h3>Type (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(cObject : Kind) → ∀(dObject : Kind) → ∀(a : cObject) → dObject → cObject
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Costar</h2>
<h3>category (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>semigroupoid (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ ∀(a : object)
→ ∀(b : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ λ(a : object)
→ λ(b : object)
→ arrow (m b) a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Coyoneda</h2>
<h3>functor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(g : object → Type)
→ { map :
        ∀(a : object)
      → ∀(b : object)
      → ∀(h : arrow a b)
      → ∀(lan : ∀(r : Type) → (∀(b : object) → arrow b a → g b → r) → r)
      → ∀(r : Type)
      → ∀(k : ∀(c : object) → arrow c b → g c → r)
      → r
  }
</pre></dd>
</dl>
<h3>lift (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(arrow : Type → Type → Type)
→ ∀ ( category
    : { identity :
          ∀(a : Type) → arrow a a
      , op :
            ∀(a : Type)
          → ∀(b : Type)
          → (∀(r : Type) → (∀(z : Type) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(g : Type → Type)
→ ∀(a : Type)
→ ∀(x : g a)
→ ∀(r : Type)
→ ∀(k : ∀(b : Type) → arrow b a → g b → r)
→ r
</pre></dd>
</dl>
<h3>lower (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(f : cObject → Type)
→ ∀ ( functor
    : { map : ∀(a : cObject) → ∀(b : cObject) → cArrow a b → f a → f b }
    )
→ ∀(a : cObject)
→ ∀(lan : ∀(r : Type) → (∀(b : cObject) → cArrow b a → f b → r) → r)
→ f a
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : object → Type)
→ ∀(a : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(f : object → Type)
→ λ(a : object)
→ ∀(r : Type) → (∀(b : object) → arrow b a → f b → r) → r
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Day</h2>
<h3>comonad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀ ( semigroupoid
    : { op :
            ∀(a : Type)
          → ∀(b : Type)
          → (∀(r : Type) → (∀(z : Type) → (z → b) → (a → z) → r) → r)
          → a
          → b
      }
    )
→ ∀(f : Type → Type)
→ ∀ ( fComonad
    : { identity :
          ∀(a : Type) → f a → a
      , map :
          ∀(a : Type) → ∀(b : Type) → (b → a) → f b → f a
      , op :
          ∀(a : Type) → f a → f (f a)
      }
    )
→ ∀(g : Type → Type)
→ ∀ ( gComonad
    : { identity :
          ∀(a : Type) → g a → a
      , map :
          ∀(a : Type) → ∀(b : Type) → (b → a) → g b → g a
      , op :
          ∀(a : Type) → g a → g (g a)
      }
    )
→ { identity :
        ∀(a : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : { _1 : Type, _2 : Type })
                → ({ _1 : b._1, _2 : b._2 } → a)
                → { _1 : f b._1, _2 : g b._2 }
                → r
              )
            → r
          )
      → a
  , map :
        ∀(b : Type)
      → ∀(a : Type)
      → ∀(fn : a → b)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : { _1 : Type, _2 : Type })
                → ({ _1 : b._1, _2 : b._2 } → a)
                → { _1 : f b._1, _2 : g b._2 }
                → r
              )
            → r
          )
      → ∀(r : Type)
      → (   ∀(b : { _1 : Type, _2 : Type })
          → ({ _1 : b._1, _2 : b._2 } → b@1)
          → { _1 : f b._1, _2 : g b._2 }
          → r
        )
      → r
  , op :
        ∀(a : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : { _1 : Type, _2 : Type })
                → ({ _1 : b._1, _2 : b._2 } → a)
                → { _1 : f b._1, _2 : g b._2 }
                → r
              )
            → r
          )
      → ∀(r : Type)
      → (   ∀(b : { _1 : Type, _2 : Type })
          → (   { _1 : b._1, _2 : b._2 }
              → ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : f b._1, _2 : g b._2 }
                  → r
                )
              → r
            )
          → { _1 : f b._1, _2 : g b._2 }
          → r
        )
      → r
  }
</pre></dd>
</dl>
<h3>convolution (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          cObject → cObject → Type
      , identity :
          cObject
      , product :
          cObject → cObject → cObject
      }
    )
→ ∀ ( v
    : { arrow :
          Type → Type → Type
      , identity :
          Type
      , product :
          Type → Type → Type
      }
    )
→ ∀(f : cObject → Type)
→ ∀(g : cObject → Type)
→ ∀(a : cObject)
→ ∀(r : Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ ( c
    : { arrow :
          cObject → cObject → Type
      , identity :
          cObject
      , product :
          cObject → cObject → cObject
      }
    )
→ λ ( v
    : { arrow :
          Type → Type → Type
      , identity :
          Type
      , product :
          Type → Type → Type
      }
    )
→ λ(f : cObject → Type)
→ λ(g : cObject → Type)
→ λ(a : cObject)
→ λ(r : Type)
→   ∀(b : { _1 : cObject, _2 : cObject })
  → c.arrow (c.product b._1 b._2) a
  → v.arrow (v.product (f b._1) (g b._2)) r
</pre></dd>
</dl>
<h3>functor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          cObject → cObject → Type
      , identity :
          cObject
      , product :
          cObject → cObject → cObject
      }
    )
→ ∀ ( semigroupoid
    : { op :
            ∀(a : cObject)
          → ∀(b : cObject)
          → (∀(r : Type) → (∀(z : cObject) → c.arrow z b → c.arrow a z → r) → r)
          → c.arrow a b
      }
    )
→ ∀(f : cObject → Type)
→ ∀(g : cObject → Type)
→ { map :
        ∀(a : cObject)
      → ∀(b : cObject)
      → ∀(fn : c.arrow a b)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : { _1 : cObject, _2 : cObject })
                → c.arrow (c.product b._1 b._2) a
                → { _1 : f b._1, _2 : g b._2 }
                → r
              )
            → r
          )
      → ∀(r : Type)
      → (   ∀(b : { _1 : cObject, _2 : cObject })
          → c.arrow (c.product b._1 b._2) b@1
          → { _1 : f b._1, _2 : g b._2 }
          → r
        )
      → r
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          cObject → cObject → Type
      , identity :
          cObject
      , product :
          cObject → cObject → cObject
      }
    )
→ ∀ ( v
    : { arrow :
          Type → Type → Type
      , identity :
          Type
      , product :
          Type → Type → Type
      }
    )
→ ∀(f : cObject → Type)
→ ∀(g : cObject → Type)
→ ∀(a : cObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ ( c
    : { arrow :
          cObject → cObject → Type
      , identity :
          cObject
      , product :
          cObject → cObject → cObject
      }
    )
→ λ ( v
    : { arrow :
          Type → Type → Type
      , identity :
          Type
      , product :
          Type → Type → Type
      }
    )
→ λ(f : cObject → Type)
→ λ(g : cObject → Type)
→ λ(a : cObject)
→   ∀(r : Type)
  → (   ∀(b : { _1 : cObject, _2 : cObject })
      → c.arrow (c.product b._1 b._2) a
      → v.product (f b._1) (g b._2)
      → r
    )
  → r
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Density</h2>
<h3>functor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dArrow : Type → Type → Type)
→ ∀ ( dSemigroupoid
    : { op :
            ∀(a : Type)
          → ∀(b : Type)
          → (∀(r : Type) → (∀(z : Type) → dArrow z b → dArrow a z → r) → r)
          → dArrow a b
      }
    )
→ ∀(f : cObject → Type)
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(h : dArrow a b)
      → ∀(lan : ∀(r : Type) → (∀(b : cObject) → dArrow (f b) a → f b → r) → r)
      → ∀(r : Type)
      → ∀(k : ∀(c : cObject) → dArrow (f c) b → f c → r)
      → r
  }
</pre></dd>
</dl>
<h3>lift (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(arrow : Type → Type → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : Type)
          → ∀(b : Type)
          → (∀(r : Type) → (∀(z : Type) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(f : Type → Type)
→ ∀ ( comonad
    : { identity :
          ∀(a : Type) → arrow (f a) a
      , map :
          ∀(a : Type) → ∀(b : Type) → arrow b a → arrow (f b) (f a)
      , op :
          ∀(a : Type) → arrow (f a) (f (f a))
      }
    )
→ ∀(a : Type)
→ ∀(x : f a)
→ ∀(r : Type)
→ ∀(k : ∀(b : Type) → arrow (f b) a → f b → r)
→ r
</pre></dd>
</dl>
<h3>lower (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( comonad
    : { identity :
          ∀(a : Type) → f a → a
      , map :
          ∀(a : Type) → ∀(b : Type) → (b → a) → f b → f a
      , op :
          ∀(a : Type) → f a → f (f a)
      }
    )
→ ∀(a : Type)
→ ∀(lan : ∀(r : Type) → (∀(b : Type) → (f b → a) → f b → r) → r)
→ f a
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(cObject : Kind) → ∀(f : cObject → Type) → ∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(f : cObject → Type)
→ λ(a : Type)
→ ∀(r : Type) → (∀(b : cObject) → (f b → a) → f b → r) → r
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./DifferenceList</h2>
<h3>applicative (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → ∀(l : List a) → List a
, op :
      ∀(i : Type)
    → ∀ ( day
        :   ∀(r : Type)
          → (   ∀(b : { _1 : Type, _2 : Type })
              → ({ _1 : b._1, _2 : b._2 } → i)
              → { _1 : List b._1 → List b._1, _2 : List b._2 → List b._2 }
              → r
            )
          → r
        )
    → List i
    → List i
}
</pre></dd>
</dl>
<h3>cons (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(y : a) → ∀(xs : List a → List a) → ∀(x : List a) → List a
</pre></dd>
</dl>
<h3>foldable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ fold :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(f : b → a → b)
    → ∀(z : b)
    → ∀(ts : List a → List a)
    → b
}
</pre></dd>
</dl>
<h3>functor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(fn : a → b)
    → ∀(f : List a → List a)
    → List b
    → List b
}
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → ∀(l : List a) → List a
, map :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(fn : a → b)
    → ∀(f : List a → List a)
    → List b
    → List b
, op :
      ∀(a : Type)
    → ∀(f : List (List a → List a) → List (List a → List a))
    → List a
    → List a
}
</pre></dd>
</dl>
<h3>monoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { identity :
      {} → ∀(x : List a) → List a
  , op :
        ∀(p : { _1 : List a → List a, _2 : List a → List a })
      → ∀(x : List a)
      → List a
  }
</pre></dd>
</dl>
<h3>semigroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { op :
        ∀(p : { _1 : List a → List a, _2 : List a → List a })
      → ∀(x : List a)
      → List a
  }
</pre></dd>
</dl>
<h3>snoc (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(xs : List a → List a) → ∀(y : a) → ∀(x : List a) → List a
</pre></dd>
</dl>
<h3>toList (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(xs : List a → List a) → List a
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → List a → List a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./docs</h2>
<h2 style="background-color: #bbb; width: 100%">./Either</h2>
<h2 style="background-color: #bbb; width: 100%">./Either/applicative</h2>
<h3>parallel (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(semigroup : { op : { _1 : a, _2 : a } → a })
→ { identity :
      ∀(b : Type) → ∀(x : b) → < Left : a | Right : b >
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(d : { _1 : Type, _2 : Type })
                → ({ _1 : d._1, _2 : d._2 } → i)
                → { _1 :
                      < Left : a | Right : d._1 >
                  , _2 :
                      < Left : a | Right : d._2 >
                  }
                → r
              )
            → r
          )
      → < Left : a | Right : i >
  }
</pre></dd>
</dl>
<h3>sequential (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { identity :
      ∀(b : Type) → ∀(x : b) → < Left : a | Right : b >
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : { _1 : Type, _2 : Type })
                → ({ _1 : b._1, _2 : b._2 } → i)
                → { _1 :
                      < Left : a | Right : b._1 >
                  , _2 :
                      < Left : a | Right : b._2 >
                  }
                → r
              )
            → r
          )
      → < Left : a | Right : i >
  }
</pre></dd>
</dl>
<h3>foldable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { fold :
        ∀(b : Type)
      → ∀(c : Type)
      → ∀(f : c → b → c)
      → ∀(z : c)
      → ∀(either : < Left : a | Right : b >)
      → c
  }
</pre></dd>
</dl>
<h3>fromLeft (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → ∀(def : a) → ∀(e : < Left : a | Right : b >) → a
</pre></dd>
</dl>
<h3>fromRight (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → ∀(def : b) → ∀(e : < Left : a | Right : b >) → b
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Either/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./Either/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { map :
        ∀(b : Type)
      → ∀(c : Type)
      → ∀(f : b → c)
      → ∀(e : < Left : a | Right : b >)
      → < Left : a | Right : c >
  }
</pre></dd>
</dl>
<h3>star (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(a : Type) → a → m a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : m b._1, _2 : m b._2 }
                  → r
                )
              → r
            )
          → m a
      }
    )
→ ∀(a : Type)
→ { map :
        ∀(b : Type)
      → ∀(c : Type)
      → ∀(f : b → m c)
      → ∀(e : < Left : a | Right : b >)
      → m < Left : a | Right : c >
  }
</pre></dd>
</dl>
<h3>pair (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b })
→ { map :
        ∀(a : { _1 : Type, _2 : Type })
      → ∀(b : { _1 : Type, _2 : Type })
      → ∀(f : { _1 : a._1 → m b._1, _2 : a._2 → m b._2 })
      → ∀(e : < Left : a._1 | Right : a._2 >)
      → m < Left : b._1 | Right : b._2 >
  }
</pre></dd>
</dl>
<h3>isLeft (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → ∀(e : < Left : a | Right : b >) → Bool
</pre></dd>
</dl>
<h3>isRight (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → ∀(e : < Left : a | Right : b >) → Bool
</pre></dd>
</dl>
<h3>lefts (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → ∀(eithers : List < Left : a | Right : b >) → List a
</pre></dd>
</dl>
<h3>mapBoth (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(c : Type)
→ ∀(d : Type)
→ ∀(f : a → c)
→ ∀(g : b → d)
→ ∀(e : < Left : a | Right : b >)
→ < Left : c | Right : d >
</pre></dd>
</dl>
<h3>mapLeft (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(c : Type)
→ ∀(f : a → c)
→ ∀(e : < Left : a | Right : b >)
→ < Left : c | Right : b >
</pre></dd>
</dl>
<h3>mapRight (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(d : Type)
→ ∀(f : b → d)
→ ∀(e : < Left : a | Right : b >)
→ < Left : a | Right : d >
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { identity :
      ∀(b : Type) → ∀(x : b) → < Left : a | Right : b >
  , map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(fn : a → b)
      → ∀(fa : < Left : a@1 | Right : a >)
      → < Left : a@1 | Right : b >
  , op :
        ∀(a : Type)
      → ∀(fa : < Left : a@1 | Right : < Left : a@1 | Right : a > >)
      → < Left : a@1 | Right : a >
  }
</pre></dd>
</dl>
<h3>partition (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(eithers : List < Left : a | Right : b >)
→ { lefts : List a, rights : List b }
</pre></dd>
</dl>
<h3>rights (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → ∀(eithers : List < Left : a | Right : b >) → List b
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ a :
      ∀(a : Type)
    → { bind :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(f : a → < Left : a@1 | Right : b >)
          → ∀(x : < Left : a@1 | Right : a >)
          → < Left : a@1 | Right : b >
      , extractEndofunctor :
          { map :
                ∀(a : Type)
              → ∀(b : Type)
              → ∀(fn : a → b)
              → ∀(fa : < Left : a@1 | Right : a >)
              → < Left : a@1 | Right : b >
          }
      , extractStarfunctor :
          { map :
                ∀(a : Type)
              → ∀(b : Type)
              → ∀(f : a → < Left : a@1 | Right : b >)
              → ∀(x : < Left : a@1 | Right : a >)
              → < Left : a@1 | Right : b >
          }
      , join :
            ∀(a : Type)
          → ∀(fa : < Left : a@1 | Right : < Left : a@1 | Right : a > >)
          → < Left : a@1 | Right : a >
      , map :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(fn : a → b)
          → ∀(fa : < Left : a@1 | Right : a >)
          → < Left : a@1 | Right : b >
      , pure :
          ∀(b : Type) → ∀(x : b) → < Left : a | Right : b >
      }
, ab :
      ∀(a : Type)
    → ∀(b : Type)
    → { Left :
          ∀(Left : a) → < Left : a | Right : b >
      , Right :
          ∀(Right : b) → < Left : a | Right : b >
      , fromLeft :
          ∀(def : a) → ∀(e : < Left : a | Right : b >) → a
      , fromRight :
          ∀(def : b) → ∀(e : < Left : a | Right : b >) → b
      , isLeft :
          ∀(e : < Left : a | Right : b >) → Bool
      , isRight :
          ∀(e : < Left : a | Right : b >) → Bool
      , lefts :
          ∀(eithers : List < Left : a | Right : b >) → List a
      , partition :
            ∀(eithers : List < Left : a | Right : b >)
          → { lefts : List a, rights : List b }
      , rights :
          ∀(eithers : List < Left : a | Right : b >) → List b
      }
, pair :
    { map :
          ∀(a : { _1 : Type, _2 : Type })
        → ∀(b : { _1 : Type, _2 : Type })
        → ∀(f : { _1 : a._1 → b._1, _2 : a._2 → b._2 })
        → ∀(e : < Left : a._1 | Right : a._2 >)
        → < Left : b._1 | Right : b._2 >
    }
, traverse :
      ∀(m : Type → Type)
    → ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b })
    → { map :
            ∀(a : { _1 : Type, _2 : Type })
          → ∀(b : { _1 : Type, _2 : Type })
          → ∀(f : { _1 : a._1 → m b._1, _2 : a._2 → m b._2 })
          → ∀(e : < Left : a._1 | Right : a._2 >)
          → m < Left : b._1 | Right : b._2 >
      }
}
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → λ(b : Type) → < Left : a | Right : b >
</pre></dd>
</dl>
<h3>unitedMonoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(semigroup : { op : { _1 : a, _2 : a } → a })
→ { additive :
      { identity :
          ∀(b : Type) → ∀(x : b) → < Left : a | Right : b >
      , op :
            ∀(i : Type)
          → ∀ ( day
              :   ∀(r : Type)
                → (   ∀(b : { _1 : Type, _2 : Type })
                    → ({ _1 : b._1, _2 : b._2 } → i)
                    → { _1 :
                          < Left : a | Right : b._1 >
                      , _2 :
                          < Left : a | Right : b._2 >
                      }
                    → r
                  )
                → r
              )
          → < Left : a | Right : i >
      }
  , multiplicative :
      { identity :
          ∀(b : Type) → ∀(x : b) → < Left : a | Right : b >
      , op :
            ∀(i : Type)
          → ∀ ( day
              :   ∀(r : Type)
                → (   ∀(d : { _1 : Type, _2 : Type })
                    → ({ _1 : d._1, _2 : d._2 } → i)
                    → { _1 :
                          < Left : a | Right : d._1 >
                      , _2 :
                          < Left : a | Right : d._2 >
                      }
                    → r
                  )
                → r
              )
          → < Left : a | Right : i >
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./EitherT</h2>
<h3>applicative (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀ ( eitherApplicative
    : { identity :
          ∀(a : Type) → a → < Left : a@1 | Right : a >
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 :
                        < Left : a@1 | Right : b._1 >
                    , _2 :
                        < Left : a@1 | Right : b._2 >
                    }
                  → r
                )
              → r
            )
          → < Left : a@1 | Right : a >
      }
    )
→ ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(a : Type) → a → m a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : m b._1, _2 : m b._2 }
                  → r
                )
              → r
            )
          → m a
      }
    )
→ { identity :
      ∀(a : Type) → ∀(x : a) → m < Left : a@1 | Right : a >
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : { _1 : Type, _2 : Type })
                → ({ _1 : b._1, _2 : b._2 } → i)
                → { _1 :
                      m < Left : a | Right : b._1 >
                  , _2 :
                      m < Left : a | Right : b._2 >
                  }
                → r
              )
            → r
          )
      → m < Left : a | Right : i >
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./EitherT/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./EitherT/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(f : Type → Type)
→ ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → f a → f b })
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(k : a → b)
      → f < Left : a@1 | Right : a >
      → f < Left : a@1 | Right : b >
  }
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(m : Type → Type)
→ ∀ ( monad
    : { identity :
          ∀(a : Type) → a → m a
      , map :
          ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b
      , op :
          ∀(a : Type) → m (m a) → m a
      }
    )
→ { identity :
      ∀(i : Type) → ∀(x : i) → m < Left : a | Right : i >
  , map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(k : a → b)
      → m < Left : a@1 | Right : a >
      → m < Left : a@1 | Right : b >
  , op :
        ∀(b : Type)
      → ∀(x : m < Left : a | Right : m < Left : a | Right : b > >)
      → m < Left : a | Right : b >
  }
</pre></dd>
</dl>
<h3>transformer (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → ∀(m : Type → Type) → ∀(b : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → λ(m : Type → Type) → λ(b : Type) → m < Left : a | Right : b >
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Eq</h2>
<h2 style="background-color: #bbb; width: 100%">./Eq/functor</h2>
<h3>contravariant (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(fn : b → a)
    → ∀(fa : { eq : a → a → Bool })
    → { eq : ∀(x : b) → ∀(y : b) → Bool }
}
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → { eq : a → a → Bool }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Field</h2>
<h3>divide (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀ ( category
    : { identity :
          ∀(a : object) → cat.arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (   ∀(r : Type)
              → (∀(z : object) → cat.arrow z b → cat.arrow a z → r)
              → r
            )
          → cat.arrow a b
      }
    )
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : cat.arrow a._1 b._1, _2 : cat.arrow a._2 b._2 }
          → cat.arrow (cat.product a._1 a._2) (cat.product b._1 b._2)
      }
    )
→ ∀(m : object)
→ ∀ ( field
    : { additive :
          { identity :
              cat.arrow cat.identity m
          , inverse :
              cat.arrow m m
          , op :
              cat.arrow (cat.product m m) m
          }
      , multiplicative :
          { identity :
              cat.arrow cat.identity m
          , inverse :
              cat.arrow m m
          , op :
              cat.arrow (cat.product m m) m
          }
      }
    )
→ cat.arrow (cat.product m m) m
</pre></dd>
</dl>
<h3>extractCommutativeRing (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( field
    : { additive :
          { identity :
              cat.arrow cat.identity m
          , inverse :
              cat.arrow m m
          , op :
              cat.arrow (cat.product m m) m
          }
      , multiplicative :
          { identity :
              cat.arrow cat.identity m
          , inverse :
              cat.arrow m m
          , op :
              cat.arrow (cat.product m m) m
          }
      }
    )
→ { additive :
      { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
  , multiplicative :
      { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
  }
</pre></dd>
</dl>
<h3>extractRing (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( field
    : { additive :
          { identity :
              cat.arrow cat.identity m
          , inverse :
              cat.arrow m m
          , op :
              cat.arrow (cat.product m m) m
          }
      , multiplicative :
          { identity :
              cat.arrow cat.identity m
          , inverse :
              cat.arrow m m
          , op :
              cat.arrow (cat.product m m) m
          }
      }
    )
→ { additive :
      { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
  , multiplicative :
      { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Field/Ordered</h2>
<h3>extractPartiallyOrderedField (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( field
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , le :
              m → m → Bool
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , preLE :
              m → m → Optional Bool
          }
      }
    )
→ { additive :
      { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  }
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( field
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , le :
              m → m → Bool
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , preLE :
              m → m → Optional Bool
          }
      }
    )
→ { add :
      { _1 : m, _2 : m } → m
  , divide :
      ∀(x : { _1 : m, _2 : m }) → m
  , eq :
      m → m → Bool
  , le :
      m → m → Bool
  , multiply :
      { _1 : m, _2 : m } → m
  , negate :
      m → m
  , one :
      {} → m
  , partialLE :
      m → m → Optional Bool
  , reciprocal :
      m → m
  , subtract :
      ∀(x : { _1 : m, _2 : m }) → m
  , zero :
      {} → m
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , le :
          m → m → Bool
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Field/PartiallyOrdered</h2>
<h3>extractField (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( field
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , preLE :
              m → m → Optional Bool
          }
      }
    )
→ { additive :
      { identity : {} → m, inverse : m → m, op : { _1 : m, _2 : m } → m }
  , multiplicative :
      { identity : {} → m, inverse : m → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( field
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , preLE :
              m → m → Optional Bool
          }
      }
    )
→ { add :
      { _1 : m, _2 : m } → m
  , divide :
      ∀(x : { _1 : m, _2 : m }) → m
  , eq :
      m → m → Bool
  , multiply :
      { _1 : m, _2 : m } → m
  , negate :
      m → m
  , one :
      {} → m
  , partialLE :
      m → m → Optional Bool
  , reciprocal :
      m → m
  , subtract :
      ∀(x : { _1 : m, _2 : m }) → m
  , zero :
      {} → m
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  }
</pre></dd>
</dl>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  }
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀ ( category
    : { identity :
          ∀(a : object) → cat.arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (   ∀(r : Type)
              → (∀(z : object) → cat.arrow z b → cat.arrow a z → r)
              → r
            )
          → cat.arrow a b
      }
    )
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : cat.arrow a._1 b._1, _2 : cat.arrow a._2 b._2 }
          → cat.arrow (cat.product a._1 a._2) (cat.product b._1 b._2)
      }
    )
→ ∀(m : object)
→ ∀ ( field
    : { additive :
          { identity :
              cat.arrow cat.identity m
          , inverse :
              cat.arrow m m
          , op :
              cat.arrow (cat.product m m) m
          }
      , multiplicative :
          { identity :
              cat.arrow cat.identity m
          , inverse :
              cat.arrow m m
          , op :
              cat.arrow (cat.product m m) m
          }
      }
    )
→ { add :
      cat.arrow (cat.product m m) m
  , divide :
      cat.arrow (cat.product m m) m
  , multiply :
      cat.arrow (cat.product m m) m
  , negate :
      cat.arrow m m
  , one :
      cat.arrow cat.identity m
  , reciprocal :
      cat.arrow m m
  , subtract :
      cat.arrow (cat.product m m) m
  , zero :
      cat.arrow cat.identity m
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
  , multiplicative :
      { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Fin2</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(object : Kind) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(object : Kind) → < One : object | Zero : object >
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Foldable</h2>
<h3>foldMap (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀(monoid : { identity : {} → m, op : { _1 : m, _2 : m } → m })
→ ∀(t : Type → Type)
→ ∀(foldable : { fold : ∀(a : Type) → ∀(b : Type) → (b → a → b) → b → t a → b })
→ ∀(a : Type)
→ ∀(f : a → m)
→ t a
→ m
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(t : Type → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(t : Type → Type)
→ { fold : ∀(a : Type) → ∀(b : Type) → (b → a → b) → b → t a → b }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Free</h2>
<h2 style="background-color: #bbb; width: 100%">./Function</h2>
<h3>arrow (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ arr :
    ∀(a : Type) → ∀(b : Type) → ∀(x : a → b) → a → b
, fanout :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : a → b)
    → ∀(g : a → c)
    → ∀(x : a)
    → { _1 : b, _2 : c }
, identity :
    ∀(a : Type) → ∀(x : a) → a
, lmap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → a)
    → ∀(p : a → c)
    → ∀(x : b)
    → c
, map :
      ∀(a : { _1 : Type, _2 : Type })
    → ∀(b : { _1 : Type, _2 : Type })
    → ∀(f : { _1 : b._1 → a._1, _2 : a._2 → b._2 })
    → ∀(fn : a._1 → a._2)
    → ∀(x : b._1)
    → b._2
, op :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(p : ∀(r : Type) → (∀(z : Type) → (z → b) → (a → z) → r) → r)
    → a
    → b
, rmap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → c)
    → ∀(p : a → b)
    → ∀(x : a)
    → c
, split :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(d : Type)
    → ∀(f : a → b)
    → ∀(g : c → d)
    → ∀(p : { _1 : a, _2 : c })
    → { _1 : b, _2 : d }
}
</pre></dd>
</dl>
<h3>category (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → a
, op :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(p : ∀(r : Type) → (∀(z : Type) → (z → b) → (a → z) → r) → r)
    → a
    → b
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Function/functor</h2>
<h3>profunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map :
      ∀(a : { _1 : Type, _2 : Type })
    → ∀(b : { _1 : Type, _2 : Type })
    → ∀(f : { _1 : b._1 → a._1, _2 : a._2 → b._2 })
    → ∀(fn : a._1 → a._2)
    → ∀(x : b._1)
    → b._2
}
</pre></dd>
</dl>
<h3>semigroupoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ op :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(p : ∀(r : Type) → (∀(z : Type) → (z → b) → (a → z) → r) → r)
    → a
    → b
}
</pre></dd>
</dl>
<h3>strong (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ lmap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → a)
    → ∀(p : a → c)
    → ∀(x : b)
    → c
, map :
      ∀(a : { _1 : Type, _2 : Type })
    → ∀(b : { _1 : Type, _2 : Type })
    → ∀(f : { _1 : b._1 → a._1, _2 : a._2 → b._2 })
    → ∀(fn : a._1 → a._2)
    → ∀(x : b._1)
    → b._2
, rmap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → c)
    → ∀(p : a → b)
    → ∀(x : a)
    → c
}
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → λ(b : Type) → a → b
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor</h2>
<h2 style="background-color: #bbb; width: 100%">./Functor/Bifunctor</h2>
<h3>impliedFirstFunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀ ( dCategory
    : { identity :
          ∀(a : dObject) → dArrow a a
      , op :
            ∀(a : dObject)
          → ∀(b : dObject)
          → (∀(r : Type) → (∀(z : dObject) → dArrow z b → dArrow a z → r) → r)
          → dArrow a b
      }
    )
→ ∀(eObject : Kind)
→ ∀(eArrow : eObject → eObject → Type)
→ ∀(f : cObject → dObject → eObject)
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : cObject, _2 : dObject })
          → ∀(b : { _1 : cObject, _2 : dObject })
          → { _1 : cArrow a._1 b._1, _2 : dArrow a._2 b._2 }
          → eArrow (f a._1 a._2) (f b._1 b._2)
      }
    )
→ ∀(a : dObject)
→ { map :
        ∀(b : cObject)
      → ∀(c : cObject)
      → ∀(fn : cArrow b c)
      → eArrow (f b a) (f c a)
  }
</pre></dd>
</dl>
<h3>impliedSecondFunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀ ( cCategory
    : { identity :
          ∀(a : cObject) → cArrow a a
      , op :
            ∀(a : cObject)
          → ∀(b : cObject)
          → (∀(r : Type) → (∀(z : cObject) → cArrow z b → cArrow a z → r) → r)
          → cArrow a b
      }
    )
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(eObject : Kind)
→ ∀(eArrow : eObject → eObject → Type)
→ ∀(f : cObject → dObject → eObject)
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : cObject, _2 : dObject })
          → ∀(b : { _1 : cObject, _2 : dObject })
          → { _1 : cArrow a._1 b._1, _2 : dArrow a._2 b._2 }
          → eArrow (f a._1 a._2) (f b._1 b._2)
      }
    )
→ ∀(a : cObject)
→ { map :
        ∀(b : dObject)
      → ∀(c : dObject)
      → ∀(fn : dArrow b c)
      → eArrow (f a b) (f a c)
  }
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀ ( cCategory
    : { identity :
          ∀(a : cObject) → cArrow a a
      , op :
            ∀(a : cObject)
          → ∀(b : cObject)
          → (∀(r : Type) → (∀(z : cObject) → cArrow z b → cArrow a z → r) → r)
          → cArrow a b
      }
    )
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀ ( dCategory
    : { identity :
          ∀(a : dObject) → dArrow a a
      , op :
            ∀(a : dObject)
          → ∀(b : dObject)
          → (∀(r : Type) → (∀(z : dObject) → dArrow z b → dArrow a z → r) → r)
          → dArrow a b
      }
    )
→ ∀(eObject : Kind)
→ ∀(eArrow : eObject → eObject → Type)
→ ∀(f : cObject → dObject → eObject)
→ ∀ ( functor
    : { map :
            ∀(a : { _1 : cObject, _2 : dObject })
          → ∀(b : { _1 : cObject, _2 : dObject })
          → { _1 : cArrow a._1 b._1, _2 : dArrow a._2 b._2 }
          → eArrow (f a._1 a._2) (f b._1 b._2)
      }
    )
→ { extractFirstFunctor :
        ∀(a : dObject)
      → { map :
              ∀(b : cObject)
            → ∀(c : cObject)
            → ∀(fn : cArrow b c)
            → eArrow (f b a) (f c a)
        }
  , extractSecondFunctor :
        ∀(a : cObject)
      → { map :
              ∀(b : dObject)
            → ∀(c : dObject)
            → ∀(fn : dArrow b c)
            → eArrow (f a b) (f a c)
        }
  , first :
        ∀(a : dObject)
      → ∀(b : cObject)
      → ∀(c : cObject)
      → ∀(fn : cArrow b c)
      → eArrow (f b a) (f c a)
  , map :
        ∀(a : { _1 : cObject, _2 : dObject })
      → ∀(b : { _1 : cObject, _2 : dObject })
      → { _1 : cArrow a._1 b._1, _2 : dArrow a._2 b._2 }
      → eArrow (f a._1 a._2) (f b._1 b._2)
  , second :
        ∀(a : cObject)
      → ∀(b : dObject)
      → ∀(c : dObject)
      → ∀(fn : dArrow b c)
      → eArrow (f a b) (f a c)
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(eObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(eArrow : eObject → eObject → Type)
→ ∀(f : cObject → dObject → eObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ(eObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dArrow : dObject → dObject → Type)
→ λ(eArrow : eObject → eObject → Type)
→ λ(f : cObject → dObject → eObject)
→ { map :
        ∀(a : { _1 : cObject, _2 : dObject })
      → ∀(b : { _1 : cObject, _2 : dObject })
      → { _1 : cArrow a._1 b._1, _2 : dArrow a._2 b._2 }
      → eArrow (f a._1 a._2) (f b._1 b._2)
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor/Compactable</h2>
<h3>compact (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( compactable
    : { map : ∀(a : Type) → ∀(b : Type) → (a → Optional b) → f a → f b }
    )
→ ∀(a : Type)
→ f (Optional a)
→ f a
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(f : Type → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(f : Type → Type)
→ { map : ∀(a : Type) → ∀(b : Type) → (a → Optional b) → f a → f b }
</pre></dd>
</dl>
<h3>Contravariant (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : cObject → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dArrow : dObject → dObject → Type)
→ λ(f : cObject → dObject)
→ { map : ∀(a : cObject) → ∀(b : cObject) → cArrow b a → dArrow (f a) (f b) }
</pre></dd>
</dl>
<h3>Costar (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ ∀(f : object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ λ(f : object → object)
→ { map : ∀(a : object) → ∀(b : object) → arrow (m b) a → arrow (f b) (f a) }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor/Endo</h2>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(f : Type → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(f : Type → Type) → { map : ∀(a : Type) → ∀(b : Type) → (a → b) → f a → f b }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor/Endo/Star</h2>
<h3>sequence (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { identity :
          ∀(a : object) → arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(f : object → object)
→ ∀(g : object → object)
→ ∀ ( functor
    : { map :
          ∀(a : object) → ∀(b : object) → arrow a (f b) → arrow (g a) (f (g b))
      }
    )
→ ∀(a : object)
→ arrow (g (f a)) (f (g a))
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ ∀(f : object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ λ(f : object → object)
→ { map :
      ∀(a : object) → ∀(b : object) → arrow a (m b) → arrow (f a) (m (f b))
  }
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : object → object)
→ ∀ ( functor
    : { map : ∀(a : object) → ∀(b : object) → arrow a b → arrow (f a) (f b) }
    )
→ { map : ∀(a : object) → ∀(b : object) → arrow a b → arrow (f a) (f b) }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(f : object → object)
→ { map : ∀(a : object) → ∀(b : object) → arrow a b → arrow (f a) (f b) }
</pre></dd>
</dl>
<h3>Hom (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : object → object → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(f : object → object → Type)
→ { map :
        ∀(a : { _1 : object, _2 : object })
      → ∀(b : { _1 : object, _2 : object })
      → { _1 : arrow b._1 a._1, _2 : arrow a._2 b._2 }
      → f a._1 a._2
      → f b._1 b._2
  }
</pre></dd>
</dl>
<h3>InternalHom (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : object → object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(f : object → object → object)
→ { map :
        ∀(a : { _1 : object, _2 : object })
      → ∀(b : { _1 : object, _2 : object })
      → { _1 : arrow b._1 a._1, _2 : arrow a._2 b._2 }
      → arrow (f a._1 a._2) (f b._1 b._2)
  }
</pre></dd>
</dl>
<h3>Monoidal (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( c
    : { arrow :
          cObject → cObject → Type
      , identity :
          cObject
      , product :
          cObject → cObject → cObject
      }
    )
→ ∀ ( d
    : { arrow :
          dObject → dObject → Type
      , identity :
          dObject
      , product :
          dObject → dObject → dObject
      }
    )
→ ∀(f : cObject → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ ( c
    : { arrow :
          cObject → cObject → Type
      , identity :
          cObject
      , product :
          cObject → cObject → cObject
      }
    )
→ λ ( d
    : { arrow :
          dObject → dObject → Type
      , identity :
          dObject
      , product :
          dObject → dObject → dObject
      }
    )
→ λ(f : cObject → dObject)
→ { identity :
      d.arrow d.identity (f c.identity)
  , map :
      ∀(a : cObject) → ∀(b : cObject) → c.arrow a b → d.arrow (f a) (f b)
  , op :
        ∀(a : cObject)
      → ∀(b : cObject)
      → d.arrow (d.product (f a) (f b)) (f (c.product a b))
  }
</pre></dd>
</dl>
<h3>opposite (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : cObject → dObject)
→ ∀ ( functor
    : { map :
          ∀(a : cObject) → ∀(b : cObject) → cArrow a b → dArrow (f a) (f b)
      }
    )
→ { map : ∀(a : cObject) → ∀(b : cObject) → cArrow b a → dArrow (f b) (f a) }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor/Pair</h2>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { identity :
          ∀(a : object) → arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(f : object → object → object)
→ ∀ ( functor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : arrow a._1 b._1, _2 : arrow a._2 b._2 }
          → arrow (f a._1 a._2) (f b._1 b._2)
      }
    )
→ { extractFirstFunctor :
        ∀(a : object)
      → { map :
              ∀(b : object)
            → ∀(c : object)
            → ∀(fn : arrow b c)
            → arrow (f b a) (f c a)
        }
  , extractSecondFunctor :
        ∀(a : object)
      → { map :
              ∀(b : object)
            → ∀(c : object)
            → ∀(fn : arrow b c)
            → arrow (f a b) (f a c)
        }
  , first :
        ∀(a : object)
      → ∀(b : object)
      → ∀(c : object)
      → ∀(fn : arrow b c)
      → arrow (f b a) (f c a)
  , map :
        ∀(a : { _1 : object, _2 : object })
      → ∀(b : { _1 : object, _2 : object })
      → { _1 : arrow a._1 b._1, _2 : arrow a._2 b._2 }
      → arrow (f a._1 a._2) (f b._1 b._2)
  , second :
        ∀(a : object)
      → ∀(b : object)
      → ∀(c : object)
      → ∀(fn : arrow b c)
      → arrow (f a b) (f a c)
  }
</pre></dd>
</dl>
<h3>type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : object → object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(f : object → object → object)
→ { map :
        ∀(a : { _1 : object, _2 : object })
      → ∀(b : { _1 : object, _2 : object })
      → { _1 : arrow a._1 b._1, _2 : arrow a._2 b._2 }
      → arrow (f a._1 a._2) (f b._1 b._2)
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor/Profunctor</h2>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀ ( cCategory
    : { identity :
          ∀(a : cObject) → cArrow a a
      , op :
            ∀(a : cObject)
          → ∀(b : cObject)
          → (∀(r : Type) → (∀(z : cObject) → cArrow z b → cArrow a z → r) → r)
          → cArrow a b
      }
    )
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀ ( dCategory
    : { identity :
          ∀(a : dObject) → dArrow a a
      , op :
            ∀(a : dObject)
          → ∀(b : dObject)
          → (∀(r : Type) → (∀(z : dObject) → dArrow z b → dArrow a z → r) → r)
          → dArrow a b
      }
    )
→ ∀(f : dObject → cObject → Type)
→ ∀ ( functor
    : { map :
            ∀(a : { _1 : dObject, _2 : cObject })
          → ∀(b : { _1 : dObject, _2 : cObject })
          → { _1 : dArrow b._1 a._1, _2 : cArrow a._2 b._2 }
          → f a._1 a._2
          → f b._1 b._2
      }
    )
→ { extractFirstFunctor :
        ∀(a : cObject)
      → { map :
            ∀(b : dObject) → ∀(c : dObject) → ∀(fn : dArrow c b) → f b a → f c a
        }
  , extractSecondFunctor :
        ∀(a : dObject)
      → { map :
            ∀(b : cObject) → ∀(c : cObject) → ∀(fn : cArrow b c) → f a b → f a c
        }
  , first :
        ∀(a : cObject)
      → ∀(b : dObject)
      → ∀(c : dObject)
      → ∀(fn : dArrow c b)
      → f b a
      → f c a
  , map :
        ∀(a : { _1 : dObject, _2 : cObject })
      → ∀(b : { _1 : dObject, _2 : cObject })
      → { _1 : dArrow b._1 a._1, _2 : cArrow a._2 b._2 }
      → f a._1 a._2
      → f b._1 b._2
  , second :
        ∀(a : dObject)
      → ∀(b : cObject)
      → ∀(c : cObject)
      → ∀(fn : cArrow b c)
      → f a b
      → f a c
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : dObject → cObject → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dArrow : dObject → dObject → Type)
→ λ(f : dObject → cObject → Type)
→ { map :
        ∀(a : { _1 : dObject, _2 : cObject })
      → ∀(b : { _1 : dObject, _2 : cObject })
      → { _1 : dArrow b._1 a._1, _2 : cArrow a._2 b._2 }
      → f a._1 a._2
      → f b._1 b._2
  }
</pre></dd>
</dl>
<h3>SetValued (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : object → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(f : object → Type)
→ { map : ∀(a : object) → ∀(b : object) → arrow a b → f a → f b }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor/Star</h2>
<h3>adjacent (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { identity :
          ∀(a : object) → arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(m : object → object)
→ ∀(n : object → object)
→ ∀(natural : ∀(a : object) → arrow (m a) (n a))
→ ∀(f : object → object)
→ ∀ ( star
    : { map :
          ∀(a : object) → ∀(b : object) → arrow a (n b) → arrow (f a) (f b)
      }
    )
→ { map :
      ∀(a : object) → ∀(b : object) → ∀(fn : arrow a (m b)) → arrow (f a) (f b)
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ ∀(f : object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ λ(f : object → object)
→ { map : ∀(a : object) → ∀(b : object) → arrow a (m b) → arrow (f a) (f b) }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : cObject → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dArrow : dObject → dObject → Type)
→ λ(f : cObject → dObject)
→ { map : ∀(a : cObject) → ∀(b : cObject) → cArrow a b → dArrow (f a) (f b) }
</pre></dd>
</dl>
<h3>void (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : Type → dObject)
→ ∀ ( functor
    : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → dArrow (f a) (f b) }
    )
→ ∀(a : Type)
→ dArrow (f a) (f {})
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Group</h2>
<h2 style="background-color: #bbb; width: 100%">./Group/Commutative</h2>
<h3>extractCommutativeMonoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
    )
→ { identity : cat.arrow cat.identity m, op : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h3>extractGroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
    )
→ { identity :
      cat.arrow cat.identity m
  , inverse :
      cat.arrow m m
  , op :
      cat.arrow (cat.product m m) m
  }
</pre></dd>
</dl>
<h3>extractMonoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
    )
→ { identity : cat.arrow cat.identity m, op : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h3>quotient (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀ ( category
    : { identity :
          ∀(a : object) → cat.arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (   ∀(r : Type)
              → (∀(z : object) → cat.arrow z b → cat.arrow a z → r)
              → r
            )
          → cat.arrow a b
      }
    )
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : cat.arrow a._1 b._1, _2 : cat.arrow a._2 b._2 }
          → cat.arrow (cat.product a._1 a._2) (cat.product b._1 b._2)
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
    )
→ cat.arrow (cat.product m m) m
</pre></dd>
</dl>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { identity :
      {} → m
  , inverse :
      m → m
  , op :
      { _1 : m, _2 : m } → m
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : object)
→ { identity :
      cat.arrow cat.identity m
  , inverse :
      cat.arrow m m
  , op :
      cat.arrow (cat.product m m) m
  }
</pre></dd>
</dl>
<h3>extractMonoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
    )
→ { identity : cat.arrow cat.identity m, op : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h3>leftQuotient (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀ ( category
    : { identity :
          ∀(a : object) → cat.arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (   ∀(r : Type)
              → (∀(z : object) → cat.arrow z b → cat.arrow a z → r)
              → r
            )
          → cat.arrow a b
      }
    )
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : cat.arrow a._1 b._1, _2 : cat.arrow a._2 b._2 }
          → cat.arrow (cat.product a._1 a._2) (cat.product b._1 b._2)
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
    )
→ cat.arrow (cat.product m m) m
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Group/Ordered</h2>
<h3>extractPartiallyOrderedGroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( group
    : { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , le :
          m → m → Bool
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      }
    )
→ { eq :
      m → m → Bool
  , identity :
      {} → m
  , inverse :
      m → m
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { eq :
      m → m → Bool
  , identity :
      {} → m
  , inverse :
      m → m
  , le :
      m → m → Bool
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Group/OrderedCommutative</h2>
<h3>extractPartiallyOrderedCommutativeGroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( group
    : { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , le :
          m → m → Bool
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
    )
→ { eq :
      m → m → Bool
  , identity :
      {} → m
  , inverse :
      m → m
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { eq :
      m → m → Bool
  , identity :
      {} → m
  , inverse :
      m → m
  , le :
      m → m → Bool
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Group/PartiallyOrdered</h2>
<h3>extractEq (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( group
    : { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      }
    )
→ { eq : m → m → Bool }
</pre></dd>
</dl>
<h3>extractGroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( group
    : { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      }
    )
→ { identity : {} → m, inverse : m → m, op : { _1 : m, _2 : m } → m }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { eq :
      m → m → Bool
  , identity :
      {} → m
  , inverse :
      m → m
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Group/PartiallyOrderedCommutative</h2>
<h3>extractCommutativeGroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( group
    : { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
    )
→ { identity : {} → m, inverse : m → m, op : { _1 : m, _2 : m } → m }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { eq :
      m → m → Bool
  , identity :
      {} → m
  , inverse :
      m → m
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h3>rightQuotient (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀ ( category
    : { identity :
          ∀(a : object) → cat.arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (   ∀(r : Type)
              → (∀(z : object) → cat.arrow z b → cat.arrow a z → r)
              → r
            )
          → cat.arrow a b
      }
    )
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : cat.arrow a._1 b._1, _2 : cat.arrow a._2 b._2 }
          → cat.arrow (cat.product a._1 a._2) (cat.product b._1 b._2)
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
    )
→ cat.arrow (cat.product m m) m
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀ ( category
    : { identity :
          ∀(a : object) → cat.arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (   ∀(r : Type)
              → (∀(z : object) → cat.arrow z b → cat.arrow a z → r)
              → r
            )
          → cat.arrow a b
      }
    )
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : cat.arrow a._1 b._1, _2 : cat.arrow a._2 b._2 }
          → cat.arrow (cat.product a._1 a._2) (cat.product b._1 b._2)
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
    )
→ { identity :
      cat.arrow cat.identity m
  , inverse :
      cat.arrow m m
  , leftQuotient :
      cat.arrow (cat.product m m) m
  , op :
      cat.arrow (cat.product m m) m
  , rightQuotient :
      cat.arrow (cat.product m m) m
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : object)
→ { identity :
      cat.arrow cat.identity m
  , inverse :
      cat.arrow m m
  , op :
      cat.arrow (cat.product m m) m
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Identity</h2>
<h3>applicative (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → a
, op :
      ∀(i : Type)
    → ∀ ( day
        :   ∀(r : Type)
          → (   ∀(b : { _1 : Type, _2 : Type })
              → ({ _1 : b._1, _2 : b._2 } → i)
              → { _1 : b._1, _2 : b._2 }
              → r
            )
          → r
        )
    → i
}
</pre></dd>
</dl>
<h3>comonad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { identity :
          ∀(a : object) → arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ { identity :
      ∀(a : object) → arrow a a
  , map :
      ∀(a : object) → ∀(b : object) → ∀(fn : arrow b a) → arrow b a
  , op :
      ∀(a : object) → arrow a a
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Identity/functor</h2>
<h3>endo (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ { map : ∀(a : object) → ∀(b : object) → ∀(fn : arrow a b) → arrow a b }
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { identity :
          ∀(a : object) → arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ { identity :
      ∀(a : object) → arrow a a
  , map :
      ∀(a : object) → ∀(b : object) → ∀(fn : arrow a b) → arrow a b
  , op :
      ∀(a : object) → arrow a a
  }
</pre></dd>
</dl>
<h3>Type (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(object : Kind) → ∀(a : object) → object
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Lan</h2>
<h3>functor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cpObject : Kind)
→ ∀(cpArrow : cpObject → cpObject → Type)
→ ∀ ( cpSemigroupoid
    : { op :
            ∀(a : cpObject)
          → ∀(b : cpObject)
          → (   ∀(r : Type)
              → (∀(z : cpObject) → cpArrow z b → cpArrow a z → r)
              → r
            )
          → cpArrow a b
      }
    )
→ ∀(f : cObject → cpObject)
→ ∀(g : cObject → Type)
→ { map :
        ∀(a : cpObject)
      → ∀(b : cpObject)
      → ∀(h : cpArrow a b)
      → ∀(lan : ∀(r : Type) → (∀(b : cObject) → cpArrow (f b) a → g b → r) → r)
      → ∀(r : Type)
      → ∀(k : ∀(c : cObject) → cpArrow (f c) b → g c → r)
      → r
  }
</pre></dd>
</dl>
<h3>lift (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(arrow : Type → Type → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : Type)
          → ∀(b : Type)
          → (∀(r : Type) → (∀(z : Type) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(f : Type → Type)
→ ∀ ( comonad
    : { identity :
          ∀(a : Type) → arrow (f a) a
      , map :
          ∀(a : Type) → ∀(b : Type) → arrow b a → arrow (f b) (f a)
      , op :
          ∀(a : Type) → arrow (f a) (f (f a))
      }
    )
→ ∀(g : Type → Type)
→ ∀(a : Type)
→ ∀(x : g a)
→ ∀(r : Type)
→ ∀(k : ∀(b : Type) → arrow (f b) a → g b → r)
→ r
</pre></dd>
</dl>
<h3>lower (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cpObject : Kind)
→ ∀(cpArrow : cpObject → cpObject → Type)
→ ∀(h : cpObject → Type)
→ ∀ ( functor
    : { map : ∀(a : cpObject) → ∀(b : cpObject) → cpArrow a b → h a → h b }
    )
→ ∀(f : cObject → cpObject)
→ ∀(g : cObject → Type)
→ ∀(duplicate : ∀(b : cObject) → g b → h (f b))
→ ∀(a : cpObject)
→ ∀(lan : ∀(r : Type) → (∀(b : cObject) → cpArrow (f b) a → g b → r) → r)
→ h a
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cpObject : Kind)
→ ∀(cpArrow : cpObject → cpObject → Type)
→ ∀(p : cObject → cpObject)
→ ∀(f : cObject → Type)
→ ∀(a : cpObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(cpObject : Kind)
→ λ(cpArrow : cpObject → cpObject → Type)
→ λ(p : cObject → cpObject)
→ λ(f : cObject → Type)
→ λ(a : cpObject)
→ ∀(r : Type) → (∀(b : cObject) → cpArrow (p b) a → f b → r) → r
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Leibniz</h2>
<h3>category (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀ ( dCategory
    : { identity :
          ∀(a : dObject) → dArrow a a
      , op :
            ∀(a : dObject)
          → ∀(b : dObject)
          → (∀(r : Type) → (∀(z : dObject) → dArrow z b → dArrow a z → r) → r)
          → dArrow a b
      }
    )
→ { identity :
      ∀(a : cObject) → { subst : ∀(f : cObject → dObject) → dArrow (f a) (f a) }
  , op :
        ∀(a : cObject)
      → ∀(b : cObject)
      → ∀ ( p
          :   ∀(r : Type)
            → (   ∀(z : cObject)
                → { subst : ∀(f : cObject → dObject) → dArrow (f z) (f b) }
                → { subst : ∀(f : cObject → dObject) → dArrow (f a) (f z) }
                → r
              )
            → r
          )
      → { subst : ∀(f : cObject → dObject) → dArrow (f a) (f b) }
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(a : cObject)
→ ∀(b : cObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ(dArrow : dObject → dObject → Type)
→ λ(a : cObject)
→ λ(b : cObject)
→ { subst : ∀(f : cObject → dObject) → dArrow (f a) (f b) }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Lens</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(s : object)
→ ∀(t : object)
→ ∀(a : object)
→ ∀(b : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(s : object)
→ λ(t : object)
→ λ(a : object)
→ λ(b : object)
→ { update : cat.arrow (cat.product s b) t, view : cat.arrow s a }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./List</h2>
<h3>applicative (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → List a
, op :
      ∀(i : Type)
    → ∀ ( day
        :   ∀(r : Type)
          → (   ∀(b : { _1 : Type, _2 : Type })
              → ({ _1 : b._1, _2 : b._2 } → i)
              → { _1 : List b._1, _2 : List b._2 }
              → r
            )
          → r
        )
    → List i
}
</pre></dd>
</dl>
<h3>foldable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ fold :
    ∀(a : Type) → ∀(b : Type) → ∀(f : b → a → b) → ∀(z : b) → ∀(fa : List a) → b
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./List/functor</h2>
<h3>compactable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map :
    ∀(a : Type) → ∀(b : Type) → ∀(f : a → Optional b) → ∀(l : List a) → List b
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./List/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map : ∀(a : Type) → ∀(b : Type) → ∀(f : a → b) → ∀(fa : List a) → List b }
</pre></dd>
</dl>
<h3>star (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(a : Type) → a → m a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : m b._1, _2 : m b._2 }
                  → r
                )
              → r
            )
          → m a
      }
    )
→ { map :
      ∀(a : Type) → ∀(b : Type) → ∀(f : a → m b) → ∀(fa : List a) → m (List b)
  }
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → List a
, map :
    ∀(a : Type) → ∀(b : Type) → ∀(f : a → b) → ∀(fa : List a) → List b
, op :
    ∀(a : Type) → ∀(mma : List (List a)) → List a
}
</pre></dd>
</dl>
<h3>monoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { identity : {} → List a, op : ∀(x : { _1 : List a, _2 : List a }) → List a }
</pre></dd>
</dl>
<h3>semigroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → { op : ∀(x : { _1 : List a, _2 : List a }) → List a }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Monad</h2>
<h3>extractEndofunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ ∀ ( monad
    : { identity :
          ∀(a : object) → arrow a (m a)
      , map :
          ∀(a : object) → ∀(b : object) → arrow a b → arrow (m a) (m b)
      , op :
          ∀(a : object) → arrow (m (m a)) (m a)
      }
    )
→ { map : ∀(a : object) → ∀(b : object) → arrow a b → arrow (m a) (m b) }
</pre></dd>
</dl>
<h3>fromPureBind (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { identity :
          ∀(a : object) → arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(f : object → object)
→ ∀(pure : ∀(a : object) → arrow a (f a))
→ ∀(bind : ∀(a : object) → ∀(b : object) → arrow a (f b) → arrow (f a) (f b))
→ { identity :
      ∀(a : object) → arrow a (f a)
  , map :
      ∀(a : object) → ∀(b : object) → ∀(fn : arrow a b) → arrow (f a) (f b)
  , op :
      ∀(a : object) → arrow (f (f a)) (f a)
  }
</pre></dd>
</dl>
<h3>impliedApplicative (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( monad
    : { identity :
          ∀(a : Type) → a → f a
      , map :
          ∀(a : Type) → ∀(b : Type) → (a → b) → f a → f b
      , op :
          ∀(a : Type) → f (f a) → f a
      }
    )
→ { identity :
      ∀(a : Type) → a → f a
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : { _1 : Type, _2 : Type })
                → ({ _1 : b._1, _2 : b._2 } → i)
                → { _1 : f b._1, _2 : f b._2 }
                → r
              )
            → r
          )
      → f i
  }
</pre></dd>
</dl>
<h3>impliedStarfunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(m : object → object)
→ ∀ ( monad
    : { identity :
          ∀(a : object) → arrow a (m a)
      , map :
          ∀(a : object) → ∀(b : object) → arrow a b → arrow (m a) (m b)
      , op :
          ∀(a : object) → arrow (m (m a)) (m a)
      }
    )
→ { map :
      ∀(a : object) → ∀(b : object) → ∀(f : arrow a (m b)) → arrow (m a) (m b)
  }
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(m : object → object)
→ ∀ ( monad
    : { identity :
          ∀(a : object) → arrow a (m a)
      , map :
          ∀(a : object) → ∀(b : object) → arrow a b → arrow (m a) (m b)
      , op :
          ∀(a : object) → arrow (m (m a)) (m a)
      }
    )
→ { bind :
      ∀(a : object) → ∀(b : object) → ∀(f : arrow a (m b)) → arrow (m a) (m b)
  , extractEndofunctor :
      { map : ∀(a : object) → ∀(b : object) → arrow a b → arrow (m a) (m b) }
  , extractStarfunctor :
      { map :
            ∀(a : object)
          → ∀(b : object)
          → ∀(f : arrow a (m b))
          → arrow (m a) (m b)
      }
  , join :
      ∀(a : object) → arrow (m (m a)) (m a)
  , map :
      ∀(a : object) → ∀(b : object) → arrow a b → arrow (m a) (m b)
  , pure :
      ∀(a : object) → arrow a (m a)
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ { identity :
      ∀(a : object) → arrow a (m a)
  , map :
      ∀(a : object) → ∀(b : object) → arrow a b → arrow (m a) (m b)
  , op :
      ∀(a : object) → arrow (m (m a)) (m a)
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Monoid</h2>
<h2 style="background-color: #bbb; width: 100%">./Monoid/Commutative</h2>
<h3>extractMonoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( monoid
    : { identity :
          {} → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
    )
→ { identity : {} → m, op : { _1 : m, _2 : m } → m }
</pre></dd>
</dl>
<h3>extractSemigroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( monoid
    : { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
    )
→ { op : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { identity :
      {} → m
  , op :
      { _1 : m, _2 : m } → m
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : object)
→ { identity : cat.arrow cat.identity m, op : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h3>extractSemigroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( monoid
    : { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
    )
→ { op : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( monoid
    : { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
    )
→ { identity : cat.arrow cat.identity m, op : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : object)
→ { identity : cat.arrow cat.identity m, op : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Natural</h2>
<h3>monoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    {} → Natural
, op :
    ∀(t : { _1 : Natural, _2 : Natural }) → Natural
}
</pre></dd>
</dl>
<h3>semiring (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ additive :
    { op : ∀(t : { _1 : Natural, _2 : Natural }) → Natural }
, multiplicative :
    { identity :
        {} → Natural
    , op :
        ∀(t : { _1 : Natural, _2 : Natural }) → Natural
    }
}
</pre></dd>
</dl>
<h3>unitedMonoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(max : { _1 : Natural, _2 : Natural } → Natural)
→ { additive :
      { identity : {} → Natural, op : { _1 : Natural, _2 : Natural } → Natural }
  , multiplicative :
      { identity :
          {} → Natural
      , op :
          ∀(t : { _1 : Natural, _2 : Natural }) → Natural
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./NaturalTransformation</h2>
<h3>category (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀ ( dCategory
    : { identity :
          ∀(a : dObject) → dArrow a a
      , op :
            ∀(a : dObject)
          → ∀(b : dObject)
          → (∀(r : Type) → (∀(z : dObject) → dArrow z b → dArrow a z → r) → r)
          → dArrow a b
      }
    )
→ { identity :
      ∀(a : cObject → dObject) → ∀(i : cObject) → dArrow (a i) (a i)
  , op :
        ∀(a : cObject → dObject)
      → ∀(b : cObject → dObject)
      → ∀ ( p
          :   ∀(r : Type)
            → (   ∀(z : cObject → dObject)
                → (∀(a : cObject) → dArrow (z a) (b a))
                → (∀(a : cObject) → dArrow (a@1 a) (z a))
                → r
              )
            → r
          )
      → ∀(i : cObject)
      → dArrow (a i) (b i)
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : cObject → dObject)
→ ∀(g : cObject → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ(dArrow : dObject → dObject → Type)
→ λ(f : cObject → dObject)
→ λ(g : cObject → dObject)
→ ∀(a : cObject) → dArrow (f a) (g a)
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./NonEmptyList</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>comonad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(nel : { head : a, tail : List a }) → a
, map :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(fn : b → a)
    → ∀(nel : { head : b, tail : List b })
    → { head : a, tail : List a }
, op :
      ∀(a : Type)
    → ∀(nel : { head : a, tail : List a })
    → { head :
          { head : a, tail : List a }
      , tail :
          List { head : a, tail : List a }
      }
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./NonEmptyList/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./NonEmptyList/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(f : a → b)
    → ∀(fa : { head : a, tail : List a })
    → { head : b, tail : List b }
}
</pre></dd>
</dl>
<h3>star (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(a : Type) → a → m a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : m b._1, _2 : m b._2 }
                  → r
                )
              → r
            )
          → m a
      }
    )
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(f : a → m b)
      → ∀(fa : { head : a, tail : List a })
      → m { head : b, tail : List b }
  }
</pre></dd>
</dl>
<h3>semigroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { op :
        ∀ ( p
          : { _1 :
                { head : a, tail : List a }
            , _2 :
                { head : a, tail : List a }
            }
          )
      → { head : a, tail : List a }
  }
</pre></dd>
</dl>
<h3>toList (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(nel : { head : a, tail : List a }) → List a
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → { head : a, tail : List a }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Optional</h2>
<h3>applicative (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → Optional a
, op :
      ∀(i : Type)
    → ∀ ( day
        :   ∀(r : Type)
          → (   ∀(b : { _1 : Type, _2 : Type })
              → ({ _1 : b._1, _2 : b._2 } → i)
              → { _1 : Optional b._1, _2 : Optional b._2 }
              → r
            )
          → r
        )
    → Optional i
}
</pre></dd>
</dl>
<h3>eq (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(eq : { eq : a → a → Bool })
→ { eq : ∀(x : Optional a) → ∀(y : Optional a) → Bool }
</pre></dd>
</dl>
<h3>foldable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ fold :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(f : b → a → b)
    → ∀(z : b)
    → ∀(ts : Optional a)
    → b
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Optional/functor</h2>
<h3>compactable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(f : a → Optional b)
    → ∀(x : Optional a)
    → Optional b
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Optional/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map :
    ∀(a : Type) → ∀(b : Type) → ∀(f : a → b) → ∀(fa : Optional a) → Optional b
}
</pre></dd>
</dl>
<h3>star (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(a : Type) → a → m a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : m b._1, _2 : m b._2 }
                  → r
                )
              → r
            )
          → m a
      }
    )
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(f : a → m b)
      → ∀(fa : Optional a)
      → m (Optional b)
  }
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → Optional a
, map :
    ∀(a : Type) → ∀(b : Type) → ∀(f : a → b) → ∀(fa : Optional a) → Optional b
, op :
    ∀(a : Type) → ∀(mma : Optional (Optional a)) → Optional a
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Ran</h2>
<h3>functor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cpObject : Kind)
→ ∀(cpArrow : cpObject → cpObject → Type)
→ ∀ ( cpSemigroupoid
    : { op :
            ∀(a : cpObject)
          → ∀(b : cpObject)
          → (   ∀(r : Type)
              → (∀(z : cpObject) → cpArrow z b → cpArrow a z → r)
              → r
            )
          → cpArrow a b
      }
    )
→ ∀(p : cObject → cpObject)
→ ∀(f : cObject → Type)
→ { map :
        ∀(a : cpObject)
      → ∀(b : cpObject)
      → ∀(fn : cpArrow a b)
      → ∀(ran : ∀(b : cObject) → cpArrow a (p b) → f b)
      → ∀(c : cObject)
      → ∀(k : cpArrow b (p c))
      → f c
  }
</pre></dd>
</dl>
<h3>lift (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cpObject : Kind)
→ ∀(dObject : Kind)
→ ∀(cpArrow : cpObject → cpObject → Type)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀ ( dSemigroupoid
    : { op :
            ∀(a : dObject)
          → ∀(b : dObject)
          → (∀(r : Type) → (∀(z : dObject) → dArrow z b → dArrow a z → r) → r)
          → dArrow a b
      }
    )
→ ∀(h : cpObject → dObject)
→ ∀ ( functor
    : { map :
          ∀(a : cpObject) → ∀(b : cpObject) → cpArrow a b → dArrow (h a) (h b)
      }
    )
→ ∀(f : cObject → cpObject)
→ ∀(g : cObject → dObject)
→ ∀(join : ∀(b : cObject) → dArrow (h (f b)) (g b))
→ ∀(a : cpObject)
→ ∀(b : cObject)
→ ∀(k : cpArrow a (f b))
→ dArrow (h a) (g b)
</pre></dd>
</dl>
<h3>lower (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(p : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(a : Type) → a → p a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : p b._1, _2 : p b._2 }
                  → r
                )
              → r
            )
          → p a
      }
    )
→ ∀(f : Type → Type)
→ ∀(a : Type)
→ ∀(ran : ∀(b : Type) → (a → p b) → f b)
→ f a
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cpObject : Kind)
→ ∀(cpArrow : cpObject → cpObject → Type)
→ ∀(p : cObject → cpObject)
→ ∀(f : cObject → Type)
→ ∀(a : cpObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(cpObject : Kind)
→ λ(cpArrow : cpObject → cpObject → Type)
→ λ(p : cObject → cpObject)
→ λ(f : cObject → Type)
→ λ(a : cpObject)
→ ∀(b : cObject) → cpArrow a (p b) → f b
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Reader</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>ask (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(r : Type) → ∀(env : r) → r
</pre></dd>
</dl>
<h3>asks (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(r : Type) → ∀(a : Type) → ∀(f : r → a) → ∀(env : r) → a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Reader/functor</h2>
<h3>hom (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ { map :
        ∀(a : { _1 : object, _2 : object })
      → ∀(b : { _1 : object, _2 : object })
      → ∀(f : { _1 : arrow b._1 a._1, _2 : arrow a._2 b._2 })
      → ∀(fa : arrow a._1 a._2)
      → arrow b._1 b._2
  }
</pre></dd>
</dl>
<h3>local (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(r : object)
→ ∀(a : object)
→ ∀(f : arrow r r)
→ ∀(reader : arrow r a)
→ arrow r a
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ { identity :
      ∀(a : Type) → ∀(x : a) → r → a
  , map :
      ∀(a : Type) → ∀(b : Type) → ∀(fn : a → b) → ∀(fa : r → a) → ∀(env : r) → b
  , op :
      ∀(a : Type) → ∀(fa : r → r → a) → ∀(env : r) → a
  }
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ { bind :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(f : a → r → b)
      → ∀(x : r → a)
      → ∀(env : r)
      → b
  , extractEndofunctor :
      { map :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(fn : a → b)
          → ∀(fa : r → a)
          → ∀(env : r)
          → b
      }
  , extractStarfunctor :
      { map :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(f : a → r → b)
          → ∀(x : r → a)
          → ∀(env : r)
          → b
      }
  , join :
      ∀(a : Type) → ∀(fa : r → r → a) → ∀(env : r) → a
  , map :
      ∀(a : Type) → ∀(b : Type) → ∀(fn : a → b) → ∀(fa : r → a) → ∀(env : r) → b
  , pure :
      ∀(a : Type) → ∀(x : a) → r → a
  , withReader :
        ∀(a : Type)
      → ∀(ePrime : Type)
      → ∀(f : ePrime → r)
      → ∀(reader : r → a)
      → ∀(x : ePrime)
      → a
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(r : object)
→ ∀(a : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(r : object)
→ λ(a : object)
→ arrow r a
</pre></dd>
</dl>
<h3>withReader (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(e : object)
→ ∀(a : object)
→ ∀(ePrime : object)
→ ∀(f : arrow ePrime e)
→ ∀(reader : arrow e a)
→ arrow ePrime a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./ReaderT</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>ask (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(a : Type) → a → m a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : m b._1, _2 : m b._2 }
                  → r
                )
              → r
            )
          → m a
      }
    )
→ ∀(env : r)
→ m r
</pre></dd>
</dl>
<h3>asks (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(a : Type) → a → m a
      , op :
            ∀(a : Type)
          → (   ∀(r : Type)
              → (   ∀(b : { _1 : Type, _2 : Type })
                  → ({ _1 : b._1, _2 : b._2 } → a)
                  → { _1 : m b._1, _2 : m b._2 }
                  → r
                )
              → r
            )
          → m a
      }
    )
→ ∀(a : Type)
→ ∀(f : r → a)
→ ∀(env : r)
→ m a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./ReaderT/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./ReaderT/functor/endo</h2>
<h3>set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>local (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(r : object)
→ ∀(m : object → object)
→ ∀(a : object)
→ ∀(f : arrow r r)
→ ∀(reader : arrow r (m a))
→ arrow r (m a)
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ ∀(m : Type → Type)
→ ∀ ( monad
    : { identity :
          ∀(a : Type) → a → m a
      , map :
          ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b
      , op :
          ∀(a : Type) → m (m a) → m a
      }
    )
→ { identity :
      ∀(a : Type) → ∀(x : a) → r → m a
  , map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(fn : a → b)
      → ∀(fa : r → m a)
      → ∀(env : r)
      → m b
  , op :
      ∀(a : Type) → ∀(fa : r → m (r → m a)) → ∀(env : r) → m a
  }
</pre></dd>
</dl>
<h3>terms.dhall (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>transformer (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ { lift :
        ∀(m : Type → Type)
      → ∀ ( monad
          : { identity :
                ∀(a : Type) → a → m a
            , map :
                ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b
            , op :
                ∀(a : Type) → m (m a) → m a
            }
          )
      → ∀(a : Type)
      → ∀(ma : m a)
      → ∀(env : r)
      → m a
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ ∀(r : object)
→ ∀(a : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ λ(r : object)
→ λ(a : object)
→ arrow r (m a)
</pre></dd>
</dl>
<h3>withReader (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(e : object)
→ ∀(m : object → object)
→ ∀(a : object)
→ ∀(ePrime : object)
→ ∀(f : arrow ePrime e)
→ ∀(reader : arrow e (m a))
→ arrow ePrime (m a)
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Rig</h2>
<h3>extractSemiring (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( rig
    : { additive :
          { identity :
              cat.arrow cat.identity m
          , op :
              cat.arrow (cat.product m m) m
          }
      , multiplicative :
          { identity :
              cat.arrow cat.identity m
          , op :
              cat.arrow (cat.product m m) m
          }
      }
    )
→ { additive :
      { op : cat.arrow (cat.product m m) m }
  , multiplicative :
      { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
  }
</pre></dd>
</dl>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { identity :
          {} → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( rig
    : { additive :
          { identity :
              cat.arrow cat.identity m
          , op :
              cat.arrow (cat.product m m) m
          }
      , multiplicative :
          { identity :
              cat.arrow cat.identity m
          , op :
              cat.arrow (cat.product m m) m
          }
      }
    )
→ { add :
      cat.arrow (cat.product m m) m
  , multiply :
      cat.arrow (cat.product m m) m
  , one :
      cat.arrow cat.identity m
  , zero :
      cat.arrow cat.identity m
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
  , multiplicative :
      { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Ring</h2>
<h2 style="background-color: #bbb; width: 100%">./Ring/Commutative</h2>
<h3>extractRing (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( ring
    : { additive :
          { identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity :
              {} → m
          , op :
              { _1 : m, _2 : m } → m
          , preLE :
              m → m → Optional Bool
          }
      }
    )
→ { additive :
      { identity : {} → m, inverse : m → m, op : { _1 : m, _2 : m } → m }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity :
          {} → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
  , multiplicative :
      { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
  }
</pre></dd>
</dl>
<h3>extractRig (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( ring
    : { additive :
          { identity :
              cat.arrow cat.identity m
          , inverse :
              cat.arrow m m
          , op :
              cat.arrow (cat.product m m) m
          }
      , multiplicative :
          { identity :
              cat.arrow cat.identity m
          , op :
              cat.arrow (cat.product m m) m
          }
      }
    )
→ { additive :
      { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
  , multiplicative :
      { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Ring/Ordered</h2>
<h3>extractPartiallyOrderedRing (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( ring
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , le :
              m → m → Bool
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity : {} → m, op : { _1 : m, _2 : m } → m }
      }
    )
→ { additive :
      { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , le :
          m → m → Bool
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Ring/PartiallyOrdered</h2>
<h3>extractRing (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( ring
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity : {} → m, op : { _1 : m, _2 : m } → m }
      }
    )
→ { additive :
      { identity : {} → m, inverse : m → m, op : { _1 : m, _2 : m } → m }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : Type)
→ { additive :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h3>subtract (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀ ( category
    : { identity :
          ∀(a : object) → cat.arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (   ∀(r : Type)
              → (∀(z : object) → cat.arrow z b → cat.arrow a z → r)
              → r
            )
          → cat.arrow a b
      }
    )
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : cat.arrow a._1 b._1, _2 : cat.arrow a._2 b._2 }
          → cat.arrow (cat.product a._1 a._2) (cat.product b._1 b._2)
      }
    )
→ ∀(m : object)
→ ∀ ( ring
    : { additive :
          { identity :
              cat.arrow cat.identity m
          , inverse :
              cat.arrow m m
          , op :
              cat.arrow (cat.product m m) m
          }
      , multiplicative :
          { identity :
              cat.arrow cat.identity m
          , op :
              cat.arrow (cat.product m m) m
          }
      }
    )
→ cat.arrow (cat.product m m) m
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀ ( category
    : { identity :
          ∀(a : object) → cat.arrow a a
      , op :
            ∀(a : object)
          → ∀(b : object)
          → (   ∀(r : Type)
              → (∀(z : object) → cat.arrow z b → cat.arrow a z → r)
              → r
            )
          → cat.arrow a b
      }
    )
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : cat.arrow a._1 b._1, _2 : cat.arrow a._2 b._2 }
          → cat.arrow (cat.product a._1 a._2) (cat.product b._1 b._2)
      }
    )
→ ∀(m : object)
→ ∀ ( ring
    : { additive :
          { identity :
              cat.arrow cat.identity m
          , inverse :
              cat.arrow m m
          , op :
              cat.arrow (cat.product m m) m
          }
      , multiplicative :
          { identity :
              cat.arrow cat.identity m
          , op :
              cat.arrow (cat.product m m) m
          }
      }
    )
→ { add :
      cat.arrow (cat.product m m) m
  , multiply :
      cat.arrow (cat.product m m) m
  , negate :
      cat.arrow m m
  , one :
      cat.arrow cat.identity m
  , subtract :
      cat.arrow (cat.product m m) m
  , zero :
      cat.arrow cat.identity m
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow cat.identity m
      , inverse :
          cat.arrow m m
      , op :
          cat.arrow (cat.product m m) m
      }
  , multiplicative :
      { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./scripts</h2>
<h2 style="background-color: #bbb; width: 100%">./Semigroup</h2>
<h3>functor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(product : object → object → object)
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : arrow a._1 b._1, _2 : arrow a._2 b._2 }
          → arrow (product a._1 a._2) (product b._1 b._2)
      }
    )
→ { map :
        ∀(a : object)
      → ∀(b : object)
      → ∀(fn : { _1 : arrow a b, _2 : arrow b a })
      → ∀(fa : { op : arrow (product a a) a })
      → { op : arrow (product b b) b }
  }
</pre></dd>
</dl>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(m : Type) → { op : { _1 : m, _2 : m } → m }
</pre></dd>
</dl>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(product : object → object → object)
→ ∀(m : object)
→ ∀(semigroup : { op : arrow (product m m) m })
→ { op : arrow (product m m) m }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(product : object → object → object)
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(product : object → object → object)
→ λ(m : object)
→ { op : arrow (product m m) m }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Semigroupoid</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(object : Kind) → ∀(m : object → object → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(m : object → object → Type)
→ { op :
        ∀(a : object)
      → ∀(b : object)
      → (∀(r : Type) → (∀(z : object) → m z b → m a z → r) → r)
      → m a b
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Semilattice</h2>
<h2 style="background-color: #bbb; width: 100%">./Semilattice/Bounded</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : object)
→ { identity : cat.arrow cat.identity m, op : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { identity :
      {} → m
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : object)
→ { identity : cat.arrow cat.identity m, op : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Semiring</h2>
<h3>terms.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ ∀ ( semiring
    : { additive :
          { op : cat.arrow (cat.product m m) m }
      , multiplicative :
          { identity :
              cat.arrow cat.identity m
          , op :
              cat.arrow (cat.product m m) m
          }
      }
    )
→ { add :
      cat.arrow (cat.product m m) m
  , multiply :
      cat.arrow (cat.product m m) m
  , one :
      cat.arrow cat.identity m
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : object)
→ { additive :
      { op : cat.arrow (cat.product m m) m }
  , multiplicative :
      { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Star</h2>
<h3>category (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(m : object → object)
→ ∀ ( monad
    : { identity :
          ∀(a : object) → arrow a (m a)
      , map :
          ∀(a : object) → ∀(b : object) → arrow a b → arrow (m a) (m b)
      , op :
          ∀(a : object) → arrow (m (m a)) (m a)
      }
    )
→ { identity :
      ∀(a : object) → arrow a (m a)
  , op :
        ∀(a : object)
      → ∀(b : object)
      → ∀ ( p
          :   ∀(r : Type)
            → (∀(z : object) → arrow z (m b) → arrow a (m z) → r)
            → r
          )
      → arrow a (m b)
  }
</pre></dd>
</dl>
<h3>semigroupoid (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ ∀(a : object)
→ ∀(b : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ λ(a : object)
→ λ(b : object)
→ arrow a (m b)
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./State</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>bifunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(product : object → object → object)
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : arrow a._1 b._1, _2 : arrow a._2 b._2 }
          → arrow (product a._1 a._2) (product b._1 b._2)
      }
    )
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ { map :
        ∀(a : { _1 : object, _2 : object })
      → ∀(b : { _1 : object, _2 : object })
      → ∀ ( f
          : { _1 :
                { _1 : arrow a._1 b._1, _2 : arrow b._1 a._1 }
            , _2 :
                arrow a._2 b._2
            }
          )
      → ∀(st : arrow a._1 (product a._1 a._2))
      → arrow b._1 (product b._1 b._2)
  }
</pre></dd>
</dl>
<h3>eval (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>exec (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./State/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./State/functor/endo</h2>
<h3>get (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(s : Type) → ∀(env : s) → { state : s, val : s }
</pre></dd>
</dl>
<h3>gets (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>modify (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>monad (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>put (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(s : Type) → ∀(new : s) → ∀(env : s) → { state : s, val : {} }
</pre></dd>
</dl>
<h3>terms.dhall (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(product : object → object → object)
→ ∀(s : object)
→ ∀(a : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(product : object → object → object)
→ λ(s : object)
→ λ(a : object)
→ arrow s (product s a)
</pre></dd>
</dl>
<h3>withState (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(product : object → object → object)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (∀(r : Type) → (∀(z : object) → arrow z b → arrow a z → r) → r)
          → arrow a b
      }
    )
→ ∀(s : object)
→ ∀(a : object)
→ ∀(f : arrow s s)
→ ∀(state : arrow s (product s a))
→ arrow s (product s a)
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./StateT</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>bifunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(product : object → object → object)
→ ∀(m : object → object)
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : arrow a._1 (m b._1), _2 : arrow a._2 (m b._2) }
          → arrow (product a._1 a._2) (m (product b._1 b._2))
      }
    )
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (   ∀(r : Type)
              → (∀(z : object) → arrow z (m b) → arrow a (m z) → r)
              → r
            )
          → arrow a (m b)
      }
    )
→ { map :
        ∀(a : { _1 : object, _2 : object })
      → ∀(b : { _1 : object, _2 : object })
      → ∀ ( f
          : { _1 :
                { _1 : arrow a._1 (m b._1), _2 : arrow b._1 (m a._1) }
            , _2 :
                arrow a._2 (m b._2)
            }
          )
      → ∀(st : arrow a._1 (m (product a._1 a._2)))
      → arrow b._1 (m (product b._1 b._2))
  }
</pre></dd>
</dl>
<h3>eval (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>exec (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./StateT/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./StateT/functor/endo</h2>
<h3>get (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(s : Type)
→ ∀(m : Type → Type)
→ ∀ ( monad
    : { identity :
          ∀(a : Type) → a → m a
      , map :
          ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b
      , op :
          ∀(a : Type) → m (m a) → m a
      }
    )
→ ∀(env : s)
→ m { state : s, val : s }
</pre></dd>
</dl>
<h3>gets (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>modify (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>monad (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>put (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(s : Type)
→ ∀(m : Type → Type)
→ ∀ ( monad
    : { identity :
          ∀(a : Type) → a → m a
      , map :
          ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b
      , op :
          ∀(a : Type) → m (m a) → m a
      }
    )
→ ∀(new : s)
→ ∀(env : s)
→ m { state : s, val : {} }
</pre></dd>
</dl>
<h3>terms.dhall (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>transformer (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(product : object → object → object)
→ ∀(m : object → object)
→ ∀(s : object)
→ ∀(a : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(product : object → object → object)
→ λ(m : object → object)
→ λ(s : object)
→ λ(a : object)
→ arrow s (m (product s a))
</pre></dd>
</dl>
<h3>withState (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(product : object → object → object)
→ ∀(m : object → object)
→ ∀ ( semigroupoid
    : { op :
            ∀(a : object)
          → ∀(b : object)
          → (   ∀(r : Type)
              → (∀(z : object) → arrow z (m b) → arrow a (m z) → r)
              → r
            )
          → arrow a (m b)
      }
    )
→ ∀(s : object)
→ ∀(a : object)
→ ∀(f : arrow s (m s))
→ ∀(state : arrow s (m (product s a)))
→ arrow s (m (product s a))
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Strong</h2>
<h3>extractProfunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : dObject → cObject → Type)
→ ∀ ( strong
    : { lmap :
            ∀(a : dObject)
          → ∀(b : dObject)
          → ∀(c : cObject)
          → dArrow b a
          → f a c
          → f b c
      , map :
            ∀(a : { _1 : dObject, _2 : cObject })
          → ∀(b : { _1 : dObject, _2 : cObject })
          → { _1 : dArrow b._1 a._1, _2 : cArrow a._2 b._2 }
          → f a._1 a._2
          → f b._1 b._2
      , rmap :
            ∀(a : dObject)
          → ∀(b : cObject)
          → ∀(c : cObject)
          → cArrow b c
          → f a b
          → f a c
      }
    )
→ { map :
        ∀(a : { _1 : dObject, _2 : cObject })
      → ∀(b : { _1 : dObject, _2 : cObject })
      → { _1 : dArrow b._1 a._1, _2 : cArrow a._2 b._2 }
      → f a._1 a._2
      → f b._1 b._2
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : dObject → cObject → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dArrow : dObject → dObject → Type)
→ λ(f : dObject → cObject → Type)
→ { lmap :
        ∀(a : dObject)
      → ∀(b : dObject)
      → ∀(c : cObject)
      → dArrow b a
      → f a c
      → f b c
  , map :
        ∀(a : { _1 : dObject, _2 : cObject })
      → ∀(b : { _1 : dObject, _2 : cObject })
      → { _1 : dArrow b._1 a._1, _2 : cArrow a._2 b._2 }
      → f a._1 a._2
      → f b._1 b._2
  , rmap :
        ∀(a : dObject)
      → ∀(b : cObject)
      → ∀(c : cObject)
      → cArrow b c
      → f a b
      → f a c
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./test</h2>
<h3>kindTuple (term)</h3>
<dl>
<dt>type</dt><dd><pre>
List Natural
</pre></dd>
</dl>
<h3>mixed-kinds (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(kv : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(kv : Type)
→ { config :
      List kv
  , desc :
      Text
  , id :
      Text
  , process :
      Text
  , requires_human_approval :
      Bool
  , target :
      Text
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Text</h2>
<h3>monoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity : {} → Text, op : ∀(a : { _1 : Text, _2 : Text }) → Text }
</pre></dd>
</dl>
<h3>semigroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ op : ∀(a : { _1 : Text, _2 : Text }) → Text }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Transformer</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(t : (object → object) → object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(t : (object → object) → object → object)
→ { lift :
        ∀(m : object → object)
      → ∀ ( monad
          : { identity :
                ∀(a : object) → arrow a (m a)
            , map :
                ∀(a : object) → ∀(b : object) → arrow a b → arrow (m a) (m b)
            , op :
                ∀(a : object) → arrow (m (m a)) (m a)
            }
          )
      → ∀(a : object)
      → arrow (m a) (t m a)
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Tuple</h2>
<h3>comonad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { identity :
      ∀(b : Type) → ∀(tup : { _1 : a, _2 : b }) → b
  , map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(fn : b → a)
      → ∀(tup : { _1 : a@1, _2 : b })
      → { _1 : a@1, _2 : a }
  , op :
        ∀(a : Type)
      → ∀(tup : { _1 : a@1, _2 : a })
      → { _1 : a@1, _2 : { _1 : a@1, _2 : a } }
  }
</pre></dd>
</dl>
<h3>curry (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(c : Type)
→ ∀(f : { _1 : a, _2 : b } → c)
→ ∀(x : a)
→ ∀(y : b)
→ c
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Tuple/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./Tuple/functor/endo</h2>
<h3>star (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b })
→ ∀(a : Type)
→ { map :
        ∀(b : Type)
      → ∀(c : Type)
      → ∀(f : b → m c)
      → ∀(t : { _1 : a, _2 : b })
      → m { _1 : a, _2 : c }
  }
</pre></dd>
</dl>
<h3>pair (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map :
      ∀(a : { _1 : Type, _2 : Type })
    → ∀(b : { _1 : Type, _2 : Type })
    → ∀(f : { _1 : a._1 → b._1, _2 : a._2 → b._2 })
    → ∀(t : { _1 : a._1, _2 : a._2 })
    → { _1 : b._1, _2 : b._2 }
}
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → λ(b : Type) → { _1 : a, _2 : b }
</pre></dd>
</dl>
<h3>uncurry (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(c : Type)
→ ∀(f : a → b → c)
→ ∀(t : { _1 : a, _2 : b })
→ c
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Unit</h2>
<h3>eq (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ eq : {} → {} → Bool }
</pre></dd>
</dl>
<h3>orderedGroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ eq :
    {} → {} → Bool
, identity :
    {} → {}
, inverse :
    {} → {}
, le :
    {} → {} → Bool
, op :
    { _1 : {}, _2 : {} } → {}
, partialLE :
    {} → {} → Optional Bool
}
</pre></dd>
</dl>
<h3>partiallyOrderedGroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ eq :
    {} → {} → Bool
, identity :
    {} → {}
, inverse :
    {} → {}
, op :
    { _1 : {}, _2 : {} } → {}
, partialLE :
    {} → {} → Optional Bool
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./UnitedMonoid</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          object → object → Type
      , identity :
          object
      , product :
          object → object → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
  , multiplicative :
      { identity :
          cat.arrow cat.identity m
      , op :
          cat.arrow (cat.product m m) m
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Void</h2>
<h3>eq (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ eq : <> → <> → Bool }
</pre></dd>
</dl>
<h3>semigroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ op : ∀(p : { _1 : <>, _2 : <> }) → <> }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Yoneda</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>foldable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀(foldable : { fold : ∀(a : Type) → ∀(b : Type) → (b → a → b) → b → f a → b })
→ { fold :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(k : b → a → b)
      → ∀(z : b)
      → ∀(yoneda : ∀(b : Type) → (a → b) → f b)
      → b
  }
</pre></dd>
</dl>
<h3>functor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀ ( cSemigroupoid
    : { op :
            ∀(a : cObject)
          → ∀(b : cObject)
          → (∀(r : Type) → (∀(z : cObject) → cArrow z b → cArrow a z → r) → r)
          → cArrow a b
      }
    )
→ ∀(f : cObject → Type)
→ { map :
        ∀(a : cObject)
      → ∀(b : cObject)
      → ∀(fn : cArrow a b)
      → ∀(ran : ∀(b : cObject) → cArrow a b → f b)
      → ∀(c : cObject)
      → ∀(k : cArrow b c)
      → f c
  }
</pre></dd>
</dl>
<h3>functor-endo-star (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>lift (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀ ( dCategory
    : { identity :
          ∀(a : dObject) → dArrow a a
      , op :
            ∀(a : dObject)
          → ∀(b : dObject)
          → (∀(r : Type) → (∀(z : dObject) → dArrow z b → dArrow a z → r) → r)
          → dArrow a b
      }
    )
→ ∀(f : cObject → dObject)
→ ∀ ( functor
    : { map :
          ∀(a : cObject) → ∀(b : cObject) → cArrow a b → dArrow (f a) (f b)
      }
    )
→ ∀(a : cObject)
→ ∀(b : cObject)
→ ∀(k : cArrow a b)
→ dArrow (f a) (f b)
</pre></dd>
</dl>
<h3>lower (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(f : Type → Type) → ∀(a : Type) → ∀(ran : ∀(b : Type) → (a → b) → f b) → f a
</pre></dd>
</dl>
<h3>monad (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : object → Type)
→ ∀(a : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(f : object → Type)
→ λ(a : object)
→ ∀(b : object) → arrow a b → f b
</pre></dd>
</dl>
</body></html>
