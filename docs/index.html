<html>
<head>
<title>dhall-bhat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<h1>dhall-bhat</h1>
<h2 style="background-color: #bbb; width: 100%">.</h2>
<h2 style="background-color: #bbb; width: 100%">./Adjunction</h2>
<h3>impliedComonad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : dObject → cObject)
→ ∀ ( fFunctor
    : { map :
          ∀(a : dObject) → ∀(b : dObject) → dArrow a b → cArrow (f a) (f b)
      }
    )
→ ∀(g : cObject → dObject)
→ ∀ ( adjunction
    : { counit :
          ∀(a : cObject) → cArrow (f (g a)) a
      , leftAdjunct :
          ∀(a : dObject) → ∀(b : cObject) → cArrow (f a) b → dArrow a (g b)
      , rightAdjunct :
          ∀(a : dObject) → ∀(b : cObject) → dArrow a (g b) → cArrow (f a) b
      , unit :
          ∀(a : dObject) → dArrow a (g (f a))
      }
    )
→ { identity :
      ∀(a : cObject) → cArrow (f (g a)) a
  , op :
      ∀(a : cObject) → cArrow (f (g a)) (f (g (f (g a))))
  }
</pre></dd>
</dl>
<h3>impliedMonad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : dObject → cObject)
→ ∀(g : cObject → dObject)
→ ∀ ( gFunctor
    : { map :
          ∀(a : cObject) → ∀(b : cObject) → cArrow a b → dArrow (g a) (g b)
      }
    )
→ ∀ ( adjunction
    : { counit :
          ∀(a : cObject) → cArrow (f (g a)) a
      , leftAdjunct :
          ∀(a : dObject) → ∀(b : cObject) → cArrow (f a) b → dArrow a (g b)
      , rightAdjunct :
          ∀(a : dObject) → ∀(b : cObject) → dArrow a (g b) → cArrow (f a) b
      , unit :
          ∀(a : dObject) → dArrow a (g (f a))
      }
    )
→ { identity :
      ∀(a : dObject) → dArrow a (g (f a))
  , op :
      ∀(a : dObject) → dArrow (g (f (g (f a)))) (g (f a))
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : dObject → cObject)
→ ∀(g : cObject → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dObject : Kind)
→ λ(dArrow : dObject → dObject → Type)
→ λ(f : dObject → cObject)
→ λ(g : cObject → dObject)
→ { counit :
      ∀(a : cObject) → cArrow (f (g a)) a
  , leftAdjunct :
      ∀(a : dObject) → ∀(b : cObject) → cArrow (f a) b → dArrow a (g b)
  , rightAdjunct :
      ∀(a : dObject) → ∀(b : cObject) → dArrow a (g b) → cArrow (f a) b
  , unit :
      ∀(a : dObject) → dArrow a (g (f a))
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Applicative</h2>
<h3>ap (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(i : Type) → i → f i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : f b, _2 : f c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → f i
      }
    )
→ ∀(a : Type)
→ ∀(b : Type)
→ ∀(fn : f (a → b))
→ ∀(fa : f a)
→ f b
</pre></dd>
</dl>
<h3>fromPureAp (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀(pure : ∀(a : Type) → a → m a)
→ ∀(ap : ∀(a : Type) → ∀(b : Type) → m (a → b) → m a → m b)
→ { identity :
      ∀(a : Type) → a → m a
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : Type)
                → ∀(c : Type)
                → { _1 : m b, _2 : m c, _3 : b → c → i }
                → r
              )
            → r
          )
      → m i
  }
</pre></dd>
</dl>
<h3>impliedEndofunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(i : Type) → i → f i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : f b, _2 : f c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → f i
      }
    )
→ { map : ∀(a : Type) → ∀(b : Type) → ∀(fn : a → b) → ∀(fa : f a) → f b }
</pre></dd>
</dl>
<h3>package.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(i : Type) → i → f i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : f b, _2 : f c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → f i
      }
    )
→ { ap :
      ∀(a : Type) → ∀(b : Type) → ∀(fn : f (a → b)) → ∀(fa : f a) → f b
  , extractFunctor :
      { map : ∀(a : Type) → ∀(b : Type) → ∀(fn : a → b) → ∀(fa : f a) → f b }
  , lift2 :
        ∀(i : Type)
      → (   ∀(r : Type)
          → (   ∀(b : Type)
              → ∀(c : Type)
              → { _1 : f b, _2 : f c, _3 : b → c → i }
              → r
            )
          → r
        )
      → f i
  , map :
      ∀(a : Type) → ∀(b : Type) → ∀(fn : a → b) → ∀(fa : f a) → f b
  , pure :
      ∀(i : Type) → i → f i
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type → Type)
→ { identity :
      ∀(i : Type) → i → m i
  , op :
        ∀(i : Type)
      → (   ∀(r : Type)
          → (   ∀(b : Type)
              → ∀(c : Type)
              → { _1 : m b, _2 : m c, _3 : b → c → i }
              → r
            )
          → r
        )
      → m i
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Arrow</h2>
<h3>extractCategory (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type → Type)
→ ∀ ( arrow
    : { arr :
          ∀(a : Type) → ∀(b : Type) → (a → b) → f a b
      , compose :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → f b c → f a b → f a c
      , fanout :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → f a b
          → f a c
          → f a { _1 : b, _2 : c }
      , identity :
          ∀(a : Type) → f a a
      , lmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → a) → f a c → f b c
      , map :
            ∀(a : { _1 : Type, _2 : Type })
          → ∀(b : { _1 : Type, _2 : Type })
          → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
          → f a._1 a._2
          → f b._1 b._2
      , rmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
      , split :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → ∀(d : Type)
          → f a b
          → f c d
          → f { _1 : a, _2 : c } { _1 : b, _2 : d }
      }
    )
→ { compose :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → f b c → f a b → f a c
  , identity :
      ∀(a : Type) → f a a
  }
</pre></dd>
</dl>
<h3>extractProfunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type → Type)
→ ∀ ( arrow
    : { arr :
          ∀(a : Type) → ∀(b : Type) → (a → b) → f a b
      , compose :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → f b c → f a b → f a c
      , fanout :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → f a b
          → f a c
          → f a { _1 : b, _2 : c }
      , identity :
          ∀(a : Type) → f a a
      , lmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → a) → f a c → f b c
      , map :
            ∀(a : { _1 : Type, _2 : Type })
          → ∀(b : { _1 : Type, _2 : Type })
          → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
          → f a._1 a._2
          → f b._1 b._2
      , rmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
      , split :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → ∀(d : Type)
          → f a b
          → f c d
          → f { _1 : a, _2 : c } { _1 : b, _2 : d }
      }
    )
→ { map :
        ∀(a : { _1 : Type, _2 : Type })
      → ∀(b : { _1 : Type, _2 : Type })
      → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
      → f a._1 a._2
      → f b._1 b._2
  }
</pre></dd>
</dl>
<h3>extractSemigroupoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type → Type)
→ ∀ ( arrow
    : { arr :
          ∀(a : Type) → ∀(b : Type) → (a → b) → f a b
      , compose :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → f b c → f a b → f a c
      , fanout :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → f a b
          → f a c
          → f a { _1 : b, _2 : c }
      , identity :
          ∀(a : Type) → f a a
      , lmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → a) → f a c → f b c
      , map :
            ∀(a : { _1 : Type, _2 : Type })
          → ∀(b : { _1 : Type, _2 : Type })
          → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
          → f a._1 a._2
          → f b._1 b._2
      , rmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
      , split :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → ∀(d : Type)
          → f a b
          → f c d
          → f { _1 : a, _2 : c } { _1 : b, _2 : d }
      }
    )
→ { compose : ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → f b c → f a b → f a c }
</pre></dd>
</dl>
<h3>extractStrong (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type → Type)
→ ∀ ( arrow
    : { arr :
          ∀(a : Type) → ∀(b : Type) → (a → b) → f a b
      , compose :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → f b c → f a b → f a c
      , fanout :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → f a b
          → f a c
          → f a { _1 : b, _2 : c }
      , identity :
          ∀(a : Type) → f a a
      , lmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → a) → f a c → f b c
      , map :
            ∀(a : { _1 : Type, _2 : Type })
          → ∀(b : { _1 : Type, _2 : Type })
          → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
          → f a._1 a._2
          → f b._1 b._2
      , rmap :
          ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
      , split :
            ∀(a : Type)
          → ∀(b : Type)
          → ∀(c : Type)
          → ∀(d : Type)
          → f a b
          → f c d
          → f { _1 : a, _2 : c } { _1 : b, _2 : d }
      }
    )
→ { lmap :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → a) → f a c → f b c
  , map :
        ∀(a : { _1 : Type, _2 : Type })
      → ∀(b : { _1 : Type, _2 : Type })
      → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
      → f a._1 a._2
      → f b._1 b._2
  , rmap :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(f : Type → Type → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(f : Type → Type → Type)
→ { arr :
      ∀(a : Type) → ∀(b : Type) → (a → b) → f a b
  , compose :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → f b c → f a b → f a c
  , fanout :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(c : Type)
      → f a b
      → f a c
      → f a { _1 : b, _2 : c }
  , identity :
      ∀(a : Type) → f a a
  , lmap :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → a) → f a c → f b c
  , map :
        ∀(a : { _1 : Type, _2 : Type })
      → ∀(b : { _1 : Type, _2 : Type })
      → { _1 : b._1 → a._1, _2 : a._2 → b._2 }
      → f a._1 a._2
      → f b._1 b._2
  , rmap :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
  , split :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(c : Type)
      → ∀(d : Type)
      → f a b
      → f c d
      → f { _1 : a, _2 : c } { _1 : b, _2 : d }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category</h2>
<h3>extractSemigroupoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { compose :
            ∀(a : object)
          → ∀(b : object)
          → ∀(c : object)
          → arrow b c
          → arrow a b
          → arrow a c
      , identity :
          ∀(a : object) → arrow a a
      }
    )
→ { compose :
        ∀(a : object)
      → ∀(b : object)
      → ∀(c : object)
      → arrow b c
      → arrow a b
      → arrow a c
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category/Op</h2>
<h3>category (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { compose :
            ∀(a : object)
          → ∀(b : object)
          → ∀(c : object)
          → arrow b c
          → arrow a b
          → arrow a c
      , identity :
          ∀(a : object) → arrow a a
      }
    )
→ { compose :
        ∀(a : object)
      → ∀(b : object)
      → ∀(c : object)
      → ∀(f : arrow c b)
      → ∀(g : arrow b a)
      → arrow c a
  , identity :
      ∀(a : object) → arrow a a
  }
</pre></dd>
</dl>
<h3>type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(a : object)
→ ∀(b : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(a : object)
→ λ(b : object)
→ arrow b a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category/Product</h2>
<h3>category (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀ ( cCategory
    : { compose :
            ∀(a : cObject)
          → ∀(b : cObject)
          → ∀(c : cObject)
          → cArrow b c
          → cArrow a b
          → cArrow a c
      , identity :
          ∀(a : cObject) → cArrow a a
      }
    )
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀ ( dCategory
    : { compose :
            ∀(a : dObject)
          → ∀(b : dObject)
          → ∀(c : dObject)
          → dArrow b c
          → dArrow a b
          → dArrow a c
      , identity :
          ∀(a : dObject) → dArrow a a
      }
    )
→ { compose :
        ∀(a : { _1 : cObject, _2 : dObject })
      → ∀(b : { _1 : cObject, _2 : dObject })
      → ∀(c : { _1 : cObject, _2 : dObject })
      → ∀(f : { _1 : cArrow b._1 c._1, _2 : dArrow b._2 c._2 })
      → ∀(g : { _1 : cArrow a._1 b._1, _2 : dArrow a._2 b._2 })
      → { _1 : cArrow a._1 c._1, _2 : dArrow a._2 c._2 }
  , identity :
        ∀(a : { _1 : cObject, _2 : dObject })
      → { _1 : cArrow a._1 a._1, _2 : dArrow a._2 a._2 }
  }
</pre></dd>
</dl>
<h3>type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(a : { _1 : cObject, _2 : dObject })
→ ∀(b : { _1 : cObject, _2 : dObject })
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dObject : Kind)
→ λ(dArrow : dObject → dObject → Type)
→ λ(a : { _1 : cObject, _2 : dObject })
→ λ(b : { _1 : cObject, _2 : dObject })
→ { _1 : cArrow a._1 b._1, _2 : dArrow a._2 b._2 }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(object : Kind) → ∀(arrow : object → object → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ { compose :
        ∀(a : object)
      → ∀(b : object)
      → ∀(c : object)
      → arrow b c
      → arrow a b
      → arrow a c
  , identity :
      ∀(a : object) → arrow a a
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Codensity</h2>
<h3>applicative (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ { identity :
      ∀(a : Type) → ∀(x : a) → ∀(b : Type) → ∀(k : a → m b) → m b
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : Type)
                → ∀(c : Type)
                → { _1 :
                      ∀(b : Type) → (b@1 → m b) → m b
                  , _2 :
                      ∀(b : Type) → (c → m b) → m b
                  , _3 :
                      b → c → i
                  }
                → r
              )
            → r
          )
      → ∀(b : Type)
      → (i → m b)
      → m b
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Codensity/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./Codensity/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(h : a → b)
      → ∀(ran : ∀(b : Type) → (a → m b) → m b)
      → ∀(c : Type)
      → ∀(k : b → m c)
      → m c
  }
</pre></dd>
</dl>
<h3>lower (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(i : Type) → i → m i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : m b, _2 : m c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → m i
      }
    )
→ ∀(a : Type)
→ ∀(ran : ∀(b : Type) → (a → m b) → m b)
→ m a
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ { identity :
      ∀(a : Type) → ∀(x : a) → ∀(b : Type) → ∀(k : a → m b) → m b
  , op :
        ∀(a : Type)
      → ∀ ( codensity
          : ∀(b : Type) → ((∀(b : Type) → (a → m b) → m b) → m b) → m b
          )
      → ∀(c : Type)
      → ∀(l : a → m c)
      → m c
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type → Type) → ∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(m : Type → Type) → λ(a : Type) → ∀(b : Type) → (a → m b) → m b
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Comonad</h2>
<h3>fromExtractExtend (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { compose :
            ∀(a : object)
          → ∀(b : object)
          → ∀(c : object)
          → arrow b c
          → arrow a b
          → arrow a c
      , identity :
          ∀(a : object) → arrow a a
      }
    )
→ ∀(w : object → object)
→ ∀(extract : ∀(a : object) → arrow (w a) a)
→ ∀ ( extend
    : ∀(a : object) → ∀(b : object) → ∀(f : arrow (w a) b) → arrow (w a) (w b)
    )
→ { identity :
      ∀(a : object) → arrow (w a) a
  , op :
      ∀(a : object) → arrow (w a) (w (w a))
  }
</pre></dd>
</dl>
<h3>impliedCostarfunctor (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>impliedEndofunctor (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ { identity :
      ∀(i : object) → arrow (m i) i
  , op :
      ∀(i : object) → arrow (m i) (m (m i))
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Compose</h2>
<h3>applicative (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( fApplicative
    : { identity :
          ∀(i : Type) → i → f i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : f b, _2 : f c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → f i
      }
    )
→ ∀(g : Type → Type)
→ ∀ ( gApplicative
    : { identity :
          ∀(i : Type) → i → g i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : g b, _2 : g c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → g i
      }
    )
→ { identity :
      ∀(a : Type) → ∀(x : a) → f (g a)
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : Type)
                → ∀(c : Type)
                → { _1 : f (g b), _2 : f (g c), _3 : b → c → i }
                → r
              )
            → r
          )
      → f (g i)
  }
</pre></dd>
</dl>
<h3>foldable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( fFoldable
    : { fold :
            ∀(a : Type)
          → ∀(ts : f a)
          → ∀(b : Type)
          → ∀(f : a → b → b)
          → ∀(z : b)
          → b
      }
    )
→ ∀(g : Type → Type)
→ ∀ ( gFoldable
    : { fold :
            ∀(a : Type)
          → ∀(ts : g a)
          → ∀(b : Type)
          → ∀(f : a → b → b)
          → ∀(z : b)
          → b
      }
    )
→ { fold :
        ∀(a : Type)
      → ∀(compose : f (g a))
      → ∀(b : Type)
      → ∀(k : a → b → b)
      → ∀(z : b)
      → b
  }
</pre></dd>
</dl>
<h3>functor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(eObject : Kind)
→ ∀(eArrow : eObject → eObject → Type)
→ ∀(f : dObject → eObject)
→ ∀ ( fFunctor
    : { map :
          ∀(a : dObject) → ∀(b : dObject) → dArrow a b → eArrow (f a) (f b)
      }
    )
→ ∀(g : cObject → dObject)
→ ∀ ( gFunctor
    : { map :
          ∀(a : cObject) → ∀(b : cObject) → cArrow a b → dArrow (g a) (g b)
      }
    )
→ { map :
        ∀(a : cObject)
      → ∀(b : cObject)
      → ∀(k : cArrow a b)
      → eArrow (f (g a)) (f (g b))
  }
</pre></dd>
</dl>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(f : Type → Type) → ∀(g : Type → Type) → ∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(f : Type → Type) → λ(g : Type → Type) → λ(a : Type) → f (g a)
</pre></dd>
</dl>
<h3>Type (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(eObject : Kind)
→ ∀(f : dObject → eObject)
→ ∀(g : cObject → dObject)
→ ∀(a : cObject)
→ eObject
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Const</h2>
<h3>Type (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(cObject : Kind) → ∀(dObject : Kind) → cObject → ∀(a : dObject) → dObject
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Costar</h2>
<h3>category (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>semigroupoid (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(w : object → object)
→ ∀(a : object)
→ ∀(b : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(w : object → object)
→ λ(a : object)
→ λ(b : object)
→ arrow (w a) b
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Day</h2>
<h3>comonad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( fComonad
    : { identity : ∀(i : Type) → f i → i, op : ∀(i : Type) → f i → f (f i) }
    )
→ ∀(g : Type → Type)
→ ∀ ( gComonad
    : { identity : ∀(i : Type) → g i → i, op : ∀(i : Type) → g i → g (g i) }
    )
→ { identity :
        ∀(a : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : Type)
                → ∀(c : Type)
                → { _1 : f b, _2 : g c, _3 : b → c → a }
                → r
              )
            → r
          )
      → a
  , op :
        ∀(a : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : Type)
                → ∀(c : Type)
                → { _1 : f b, _2 : g c, _3 : b → c → a }
                → r
              )
            → r
          )
      → ∀(r : Type)
      → (   ∀(b : Type)
          → ∀(c : Type)
          → { _1 :
                f b
            , _2 :
                g c
            , _3 :
                  b
                → c
                → ∀(r : Type)
                → (   ∀(b : Type)
                    → ∀(c : Type)
                    → { _1 : f b, _2 : g c, _3 : b → c → a }
                    → r
                  )
                → r
            }
          → r
        )
      → r
  }
</pre></dd>
</dl>
<h3>convolution (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(f : Type → Type) → ∀(g : Type → Type) → ∀(a : Type) → ∀(r : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(f : Type → Type)
→ λ(g : Type → Type)
→ λ(a : Type)
→ λ(r : Type)
→ ∀(b : Type) → ∀(c : Type) → { _1 : f b, _2 : g c, _3 : b → c → a } → r
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(f : Type → Type) → ∀(g : Type → Type) → ∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(f : Type → Type)
→ λ(g : Type → Type)
→ λ(a : Type)
→   ∀(r : Type)
  → (∀(b : Type) → ∀(c : Type) → { _1 : f b, _2 : g c, _3 : b → c → a } → r)
  → r
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./docs</h2>
<h2 style="background-color: #bbb; width: 100%">./Either</h2>
<h2 style="background-color: #bbb; width: 100%">./Either/applicative</h2>
<h3>parallel (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(semigroup : { op : { _1 : a, _2 : a } → a })
→ { identity :
      ∀(b : Type) → ∀(x : b) → < Left : a | Right : b >
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : Type)
                → ∀(c : Type)
                → { _1 :
                      < Left : a | Right : b >
                  , _2 :
                      < Left : a | Right : c >
                  , _3 :
                      b → c → i
                  }
                → r
              )
            → r
          )
      → < Left : a | Right : i >
  }
</pre></dd>
</dl>
<h3>sequential (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>fold (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(c : Type)
→ ∀(f : a → c)
→ ∀(g : b → c)
→ ∀(e : < Left : a | Right : b >)
→ c
</pre></dd>
</dl>
<h3>foldable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { fold :
        ∀(b : Type)
      → ∀(either : < Left : a | Right : b >)
      → ∀(c : Type)
      → ∀(f : b → c → c)
      → ∀(z : c)
      → c
  }
</pre></dd>
</dl>
<h3>fromLeft (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → ∀(def : a) → ∀(e : < Left : a | Right : b >) → a
</pre></dd>
</dl>
<h3>fromRight (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → ∀(def : b) → ∀(e : < Left : a | Right : b >) → b
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Either/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./Either/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { map :
        ∀(b : Type)
      → ∀(c : Type)
      → ∀(f : b → c)
      → ∀(e : < Left : a | Right : b >)
      → < Left : a | Right : c >
  }
</pre></dd>
</dl>
<h3>star (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(i : Type) → i → m i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : m b, _2 : m c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → m i
      }
    )
→ ∀(a : Type)
→ { map :
        ∀(b : Type)
      → ∀(c : Type)
      → ∀(f : b → m c)
      → ∀(e : < Left : a | Right : b >)
      → m < Left : a | Right : c >
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Either/functor/fromProduct</h2>
<h3>pair (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b })
→ { map :
        ∀(a : { _1 : Type, _2 : Type })
      → ∀(b : { _1 : Type, _2 : Type })
      → ∀(f : { _1 : a._1 → m b._1, _2 : a._2 → m b._2 })
      → ∀(e : < Left : a._1 | Right : a._2 >)
      → m < Left : b._1 | Right : b._2 >
  }
</pre></dd>
</dl>
<h3>isLeft (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → ∀(e : < Left : a | Right : b >) → Bool
</pre></dd>
</dl>
<h3>isRight (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → ∀(e : < Left : a | Right : b >) → Bool
</pre></dd>
</dl>
<h3>lefts (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → ∀(eithers : List < Left : a | Right : b >) → List a
</pre></dd>
</dl>
<h3>mapBoth (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(c : Type)
→ ∀(d : Type)
→ ∀(f : a → c)
→ ∀(g : b → d)
→ ∀(e : < Left : a | Right : b >)
→ < Left : c | Right : d >
</pre></dd>
</dl>
<h3>mapLeft (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(c : Type)
→ ∀(f : a → c)
→ ∀(e : < Left : a | Right : b >)
→ < Left : c | Right : b >
</pre></dd>
</dl>
<h3>mapRight (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(d : Type)
→ ∀(f : b → d)
→ ∀(e : < Left : a | Right : b >)
→ < Left : a | Right : d >
</pre></dd>
</dl>
<h3>monad (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>package.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ { Left :
      ∀(Left : a) → < Left : a | Right : b >
  , Right :
      ∀(Right : b) → < Left : a | Right : b >
  , fromLeft :
      ∀(def : a) → ∀(e : < Left : a | Right : b >) → a
  , fromRight :
      ∀(def : b) → ∀(e : < Left : a | Right : b >) → b
  , isLeft :
      ∀(e : < Left : a | Right : b >) → Bool
  , isRight :
      ∀(e : < Left : a | Right : b >) → Bool
  , lefts :
      ∀(eithers : List < Left : a | Right : b >) → List a
  , map :
        ∀(a : { _1 : Type, _2 : Type })
      → ∀(b : { _1 : Type, _2 : Type })
      → ∀(f : { _1 : a._1 → b._1, _2 : a._2 → b._2 })
      → ∀(e : < Left : a._1 | Right : a._2 >)
      → < Left : b._1 | Right : b._2 >
  , partition :
        ∀(eithers : List < Left : a | Right : b >)
      → { lefts : List a, rights : List b }
  , rights :
      ∀(eithers : List < Left : a | Right : b >) → List b
  , traverse :
        ∀(m : Type → Type)
      → ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b })
      → { map :
              ∀(a : { _1 : Type, _2 : Type })
            → ∀(b : { _1 : Type, _2 : Type })
            → ∀(f : { _1 : a._1 → m b._1, _2 : a._2 → m b._2 })
            → ∀(e : < Left : a._1 | Right : a._2 >)
            → m < Left : b._1 | Right : b._2 >
        }
  }
</pre></dd>
</dl>
<h3>partition (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(eithers : List < Left : a | Right : b >)
→ { lefts : List a, rights : List b }
</pre></dd>
</dl>
<h3>rights (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → ∀(eithers : List < Left : a | Right : b >) → List b
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → λ(b : Type) → < Left : a | Right : b >
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./EitherT</h2>
<h2 style="background-color: #bbb; width: 100%">./EitherT/Applicative</h2>
<h3>parallel (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(semigroup : { op : { _1 : a, _2 : a } → a })
→ ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(i : Type) → i → m i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : m b, _2 : m c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → m i
      }
    )
→ { identity :
      ∀(a : Type) → ∀(x : a) → m < Left : a@1 | Right : a >
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(b : Type)
                → ∀(c : Type)
                → { _1 :
                      m < Left : a | Right : b >
                  , _2 :
                      m < Left : a | Right : c >
                  , _3 :
                      b → c → i
                  }
                → r
              )
            → r
          )
      → m < Left : a | Right : i >
  }
</pre></dd>
</dl>
<h3>sequential (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./EitherT/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./EitherT/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(f : Type → Type)
→ ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → f a → f b })
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(k : a → b)
      → f < Left : a@1 | Right : a >
      → f < Left : a@1 | Right : b >
  }
</pre></dd>
</dl>
<h3>monad (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>transformer (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → ∀(m : Type → Type) → ∀(b : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → λ(m : Type → Type) → λ(b : Type) → m < Left : a | Right : b >
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Foldable</h2>
<h3>foldMap (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀(monoid : { identity : {} → m, op : { _1 : m, _2 : m } → m })
→ ∀(t : Type → Type)
→ ∀ ( foldable
    : { fold :
            ∀(a : Type)
          → ∀(ts : t a)
          → ∀(b : Type)
          → ∀(f : a → b → b)
          → ∀(z : b)
          → b
      }
    )
→ ∀(a : Type)
→ ∀(f : a → m)
→ ∀(ts : t a)
→ m
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(t : Type → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(t : Type → Type)
→ { fold :
      ∀(a : Type) → ∀(ts : t a) → ∀(b : Type) → ∀(f : a → b → b) → ∀(z : b) → b
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Function</h2>
<h3>arrow (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ arr :
    ∀(a : Type) → ∀(b : Type) → ∀(x : a → b) → a → b
, compose :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → c)
    → ∀(g : a → b)
    → ∀(x : a)
    → c
, fanout :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : a → b)
    → ∀(g : a → c)
    → ∀(x : a)
    → { _1 : b, _2 : c }
, identity :
    ∀(a : Type) → ∀(x : a) → a
, lmap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → a)
    → ∀(p : a → c)
    → ∀(x : b)
    → c
, map :
      ∀(a : { _1 : Type, _2 : Type })
    → ∀(b : { _1 : Type, _2 : Type })
    → ∀(f : { _1 : b._1 → a._1, _2 : a._2 → b._2 })
    → ∀(fn : a._1 → a._2)
    → ∀(x : b._1)
    → b._2
, rmap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → c)
    → ∀(p : a → b)
    → ∀(x : a)
    → c
, split :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(d : Type)
    → ∀(f : a → b)
    → ∀(g : c → d)
    → ∀(p : { _1 : a, _2 : c })
    → { _1 : b, _2 : d }
}
</pre></dd>
</dl>
<h3>category (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ compose :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → c)
    → ∀(g : a → b)
    → ∀(x : a)
    → c
, identity :
    ∀(a : Type) → ∀(x : a) → a
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Function/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./Function/functor/fromProduct</h2>
<h3>profunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map :
      ∀(a : { _1 : Type, _2 : Type })
    → ∀(b : { _1 : Type, _2 : Type })
    → ∀(f : { _1 : b._1 → a._1, _2 : a._2 → b._2 })
    → ∀(fn : a._1 → a._2)
    → ∀(x : b._1)
    → b._2
}
</pre></dd>
</dl>
<h3>profunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ dimap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(d : Type)
    → ∀(f : a → b)
    → ∀(g : c → d)
    → ∀(fn : b → c)
    → ∀(x : a)
    → d
, lmap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(fn : a → b)
    → ∀(fn : b → c)
    → ∀(x : a)
    → c
, rmap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(g : b → c)
    → ∀(fn : a → b)
    → ∀(x : a)
    → c
}
</pre></dd>
</dl>
<h3>semigroupoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ compose :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → c)
    → ∀(g : a → b)
    → ∀(x : a)
    → c
}
</pre></dd>
</dl>
<h3>strong (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ lmap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → a)
    → ∀(p : a → c)
    → ∀(x : b)
    → c
, map :
      ∀(a : { _1 : Type, _2 : Type })
    → ∀(b : { _1 : Type, _2 : Type })
    → ∀(f : { _1 : b._1 → a._1, _2 : a._2 → b._2 })
    → ∀(fn : a._1 → a._2)
    → ∀(x : b._1)
    → b._2
, rmap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → c)
    → ∀(p : a → b)
    → ∀(x : a)
    → c
}
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → λ(b : Type) → a → b
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor</h2>
<h2 style="background-color: #bbb; width: 100%">./Functor/Bifunctor</h2>
<h3>first (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(eObject : Kind)
→ ∀(eArrow : eObject → eObject → Type)
→ ∀ ( eCategory
    : { compose :
            ∀(a : eObject)
          → ∀(b : eObject)
          → ∀(c : eObject)
          → eArrow b c
          → eArrow a b
          → eArrow a c
      , identity :
          ∀(a : eObject) → eArrow a a
      }
    )
→ ∀(f : { _1 : cObject, _2 : eObject } → { _1 : dObject, _2 : eObject })
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : cObject, _2 : eObject })
          → ∀(b : { _1 : cObject, _2 : eObject })
          → { _1 : cArrow a._1 b._1, _2 : eArrow a._2 b._2 }
          → { _1 : dArrow (f a)._1 (f b)._1, _2 : eArrow (f a)._2 (f b)._2 }
      }
    )
→ ∀(a : cObject)
→ ∀(b : cObject)
→ ∀(c : eObject)
→ ∀(fn : cArrow a b)
→ { _1 :
      dArrow (f { _1 = a, _2 = c })._1 (f { _1 = b, _2 = c })._1
  , _2 :
      eArrow (f { _1 = a, _2 = c })._2 (f { _1 = b, _2 = c })._2
  }
</pre></dd>
</dl>
<h3>second (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀ ( cCategory
    : { compose :
            ∀(a : cObject)
          → ∀(b : cObject)
          → ∀(c : cObject)
          → cArrow b c
          → cArrow a b
          → cArrow a c
      , identity :
          ∀(a : cObject) → cArrow a a
      }
    )
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(eObject : Kind)
→ ∀(eArrow : eObject → eObject → Type)
→ ∀(f : { _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : eObject })
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : cObject, _2 : dObject })
          → ∀(b : { _1 : cObject, _2 : dObject })
          → { _1 : cArrow a._1 b._1, _2 : dArrow a._2 b._2 }
          → { _1 : cArrow (f a)._1 (f b)._1, _2 : eArrow (f a)._2 (f b)._2 }
      }
    )
→ ∀(a : cObject)
→ ∀(b : dObject)
→ ∀(c : dObject)
→ ∀(fn : dArrow b c)
→ { _1 :
      cArrow (f { _1 = a, _2 = b })._1 (f { _1 = a, _2 = c })._1
  , _2 :
      eArrow (f { _1 = a, _2 = b })._2 (f { _1 = a, _2 = c })._2
  }
</pre></dd>
</dl>
<h3>type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : { _1 : cObject, _2 : dObject@1 } → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dObject : Kind)
→ λ(dArrow : dObject → dObject → Type)
→ λ(dObject : Kind)
→ λ(dArrow : dObject → dObject → Type)
→ λ(f : { _1 : cObject, _2 : dObject@1 } → dObject)
→ { map :
        ∀(a : { _1 : cObject, _2 : dObject@1 })
      → ∀(b : { _1 : cObject, _2 : dObject@1 })
      → { _1 : cArrow a._1 b._1, _2 : dArrow@1 a._2 b._2 }
      → dArrow (f a) (f b)
  }
</pre></dd>
</dl>
<h3>Contravariant (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : object → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(dObject : Kind)
→ λ(dArrow : dObject → dObject → Type)
→ λ(f : object → dObject)
→ { map : ∀(a : object) → ∀(b : object) → arrow b a → dArrow (f a) (f b) }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor/Endo</h2>
<h3>package.dhall (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : object → object)
→ ∀ ( functor
    : { map : ∀(a : object) → ∀(b : object) → arrow a b → arrow (f a) (f b) }
    )
→ { map : ∀(a : object) → ∀(b : object) → arrow a b → arrow (f a) (f b) }
</pre></dd>
</dl>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(f : Type → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(f : Type → Type) → { map : ∀(a : Type) → ∀(b : Type) → (a → b) → f a → f b }
</pre></dd>
</dl>
<h3>Star (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ ∀(f : object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ λ(f : object → object)
→ { map :
      ∀(a : object) → ∀(b : object) → arrow a (m b) → arrow (f a) (m (f b))
  }
</pre></dd>
</dl>
<h3>type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(f : object → object)
→ { map : ∀(a : object) → ∀(b : object) → arrow a b → arrow (f a) (f b) }
</pre></dd>
</dl>
<h3>Hom (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : { _1 : object, _2 : object } → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(f : { _1 : object, _2 : object } → Type)
→ { map :
        ∀(a : { _1 : object, _2 : object })
      → ∀(b : { _1 : object, _2 : object })
      → { _1 : arrow b._1 a._1, _2 : arrow a._2 b._2 }
      → f a
      → f b
  }
</pre></dd>
</dl>
<h3>InternalHom (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : { _1 : object, _2 : object } → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(f : { _1 : object, _2 : object } → object)
→ { map :
        ∀(a : { _1 : object, _2 : object })
      → ∀(b : { _1 : object, _2 : object })
      → { _1 : arrow b._1 a._1, _2 : arrow a._2 b._2 }
      → arrow (f a) (f b)
  }
</pre></dd>
</dl>
<h3>opposite (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : cObject → dObject)
→ ∀ ( functor
    : { map :
          ∀(a : cObject) → ∀(b : cObject) → cArrow a b → dArrow (f a) (f b)
      }
    )
→ { map : ∀(a : cObject) → ∀(b : cObject) → cArrow b a → dArrow (f b) (f a) }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor/Pair</h2>
<h3>first (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( eCategory
    : { compose :
            ∀(a : object)
          → ∀(b : object)
          → ∀(c : object)
          → arrow b c
          → arrow a b
          → arrow a c
      , identity :
          ∀(a : object) → arrow a a
      }
    )
→ ∀(f : { _1 : object, _2 : object } → { _1 : object, _2 : object })
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : arrow a._1 b._1, _2 : arrow a._2 b._2 }
          → { _1 : arrow (f a)._1 (f b)._1, _2 : arrow (f a)._2 (f b)._2 }
      }
    )
→ ∀(a : object)
→ ∀(b : object)
→ ∀(c : object)
→ ∀(fn : arrow a b)
→ { _1 :
      arrow (f { _1 = a, _2 = c })._1 (f { _1 = b, _2 = c })._1
  , _2 :
      arrow (f { _1 = a, _2 = c })._2 (f { _1 = b, _2 = c })._2
  }
</pre></dd>
</dl>
<h3>second (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { compose :
            ∀(a : object)
          → ∀(b : object)
          → ∀(c : object)
          → arrow b c
          → arrow a b
          → arrow a c
      , identity :
          ∀(a : object) → arrow a a
      }
    )
→ ∀(f : { _1 : object, _2 : object } → { _1 : object, _2 : object })
→ ∀ ( bifunctor
    : { map :
            ∀(a : { _1 : object, _2 : object })
          → ∀(b : { _1 : object, _2 : object })
          → { _1 : arrow a._1 b._1, _2 : arrow a._2 b._2 }
          → { _1 : arrow (f a)._1 (f b)._1, _2 : arrow (f a)._2 (f b)._2 }
      }
    )
→ ∀(a : object)
→ ∀(b : object)
→ ∀(c : object)
→ ∀(fn : arrow b c)
→ { _1 :
      arrow (f { _1 = a, _2 = b })._1 (f { _1 = a, _2 = c })._1
  , _2 :
      arrow (f { _1 = a, _2 = b })._2 (f { _1 = a, _2 = c })._2
  }
</pre></dd>
</dl>
<h3>type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(f : { _1 : object, _2 : object } → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(f : { _1 : object, _2 : object } → object)
→ { map :
        ∀(a : { _1 : object, _2 : object })
      → ∀(b : { _1 : object, _2 : object })
      → { _1 : arrow a._1 b._1, _2 : arrow a._2 b._2 }
      → arrow (f a) (f b)
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor/Product</h2>
<h3>Profunctor (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : { _1 : dObject, _2 : cObject } → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dObject : Kind)
→ λ(dArrow : dObject → dObject → Type)
→ λ(f : { _1 : dObject, _2 : cObject } → Type)
→ { map :
        ∀(a : { _1 : dObject, _2 : cObject })
      → ∀(b : { _1 : dObject, _2 : cObject })
      → { _1 : dArrow b._1 a._1, _2 : cArrow a._2 b._2 }
      → f a
      → f b
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor/ToTypes</h2>
<h2 style="background-color: #bbb; width: 100%">./Functor/ToTypes/Compactable</h2>
<h3>compact (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( compactable
    : { map : ∀(a : Type) → ∀(b : Type) → (a → Optional b) → f a → f b }
    )
→ ∀(a : Type)
→ f (Optional a)
→ f a
</pre></dd>
</dl>
<h3>type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(f : Type → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(f : Type → Type)
→ { map : ∀(a : Type) → ∀(b : Type) → (a → Optional b) → f a → f b }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor/ToTypes/Costar</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ ∀(f : object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ λ(f : object → object)
→ { map : ∀(a : object) → ∀(b : object) → arrow a (m b) → arrow (f a) (f b) }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor/ToTypes/Star</h2>
<h3>adjacent (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀(n : Type → Type)
→ ∀(natural : ∀(a : Type) → m a → n a)
→ ∀(f : Type → Type)
→ ∀(star : { map : ∀(a : Type) → ∀(b : Type) → (a → n b) → f a → f b })
→ { map : ∀(a : Type) → ∀(b : Type) → ∀(fn : a → m b) → f a → f b }
</pre></dd>
</dl>
<h3>type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ ∀(f : object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ λ(f : object → object)
→ { map : ∀(a : object) → ∀(b : object) → arrow a (m b) → arrow (f a) (f b) }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : cObject → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dObject : Kind)
→ λ(dArrow : dObject → dObject → Type)
→ λ(f : cObject → dObject)
→ { map : ∀(a : cObject) → ∀(b : cObject) → cArrow a b → dArrow (f a) (f b) }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Identity</h2>
<h3>applicative (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → a
, op :
      ∀(i : Type)
    → ∀ ( day
        :   ∀(r : Type)
          → (∀(b : Type) → ∀(c : Type) → { _1 : b, _2 : c, _3 : b → c → i } → r)
          → r
        )
    → i
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Identity/functor</h2>
<h3>endo (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ { map : ∀(a : object) → ∀(b : object) → ∀(fn : arrow a b) → arrow a b }
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { compose :
            ∀(a : object)
          → ∀(b : object)
          → ∀(c : object)
          → arrow b c
          → arrow a b
          → arrow a c
      , identity :
          ∀(a : object) → arrow a a
      }
    )
→ { identity : ∀(a : object) → arrow a a, op : ∀(a : object) → arrow a a }
</pre></dd>
</dl>
<h3>Type (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(object : Kind) → ∀(a : object) → object
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./List</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>foldable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ fold :
      ∀(a : Type)
    → List a
    → ∀(list : Type)
    → ∀(cons : a → list → list)
    → ∀(nil : list)
    → list
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./List/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./List/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map : ∀(a : Type) → ∀(b : Type) → ∀(f : a → b) → ∀(fa : List a) → List b }
</pre></dd>
</dl>
<h3>star (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(i : Type) → i → m i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : m b, _2 : m c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → m i
      }
    )
→ { map :
      ∀(a : Type) → ∀(b : Type) → ∀(f : a → m b) → ∀(fa : List a) → m (List b)
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./List/functor/toTypes</h2>
<h3>compactable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map :
    ∀(a : Type) → ∀(b : Type) → ∀(f : a → Optional b) → ∀(l : List a) → List b
}
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → List a
, op :
    ∀(a : Type) → ∀(mma : List (List a)) → List a
}
</pre></dd>
</dl>
<h3>monoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { identity : {} → List a, op : ∀(x : { _1 : List a, _2 : List a }) → List a }
</pre></dd>
</dl>
<h3>semigroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → { op : ∀(x : { _1 : List a, _2 : List a }) → List a }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Monad</h2>
<h3>fromPureBind (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀ ( category
    : { compose :
            ∀(a : object)
          → ∀(b : object)
          → ∀(c : object)
          → arrow b c
          → arrow a b
          → arrow a c
      , identity :
          ∀(a : object) → arrow a a
      }
    )
→ ∀(f : object → object)
→ ∀(pure : ∀(a : object) → arrow a (f a))
→ ∀(bind : ∀(a : object) → ∀(b : object) → arrow a (f b) → arrow (f a) (f b))
→ { identity :
      ∀(a : object) → arrow a (f a)
  , op :
      ∀(a : object) → arrow (f (f a)) (f a)
  }
</pre></dd>
</dl>
<h3>impliedApplicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>impliedEndofunctor (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>impliedStarfunctor (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>package.dhall (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ { identity :
      ∀(i : object) → arrow i (m i)
  , op :
      ∀(i : object) → arrow (m (m i)) (m i)
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Monoid</h2>
<h3>extractSemigroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(product : object → object → object)
→ ∀(i : object)
→ ∀(m : object)
→ ∀(t : { identity : arrow i m, op : arrow (product m m) m })
→ { op : arrow (product m m) m }
</pre></dd>
</dl>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(m : Type) → { identity : {} → m, op : { _1 : m, _2 : m } → m }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(product : object → object → object)
→ ∀(i : object)
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(product : object → object → object)
→ λ(i : object)
→ λ(m : object)
→ { identity : arrow i m, op : arrow (product m m) m }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Natural</h2>
<h3>monoid (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    {} → Natural
, op :
    ∀(t : { _1 : Natural, _2 : Natural }) → Natural
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./NaturalTransformation</h2>
<h3>category (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀ ( dCategory
    : { compose :
            ∀(a : dObject)
          → ∀(b : dObject)
          → ∀(c : dObject)
          → dArrow b c
          → dArrow a b
          → dArrow a c
      , identity :
          ∀(a : dObject) → dArrow a a
      }
    )
→ { compose :
        ∀(a : cObject → dObject)
      → ∀(b : cObject → dObject)
      → ∀(c : cObject → dObject)
      → ∀(f : ∀(i : cObject) → dArrow (b i) (c i))
      → ∀(g : ∀(i : cObject) → dArrow (a i) (b i))
      → ∀(i : cObject)
      → dArrow (a i) (c i)
  , identity :
      ∀(a : cObject → dObject) → ∀(i : cObject) → dArrow (a i) (a i)
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(a : cObject → dObject)
→ ∀(b : cObject → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ(dArrow : dObject → dObject → Type)
→ λ(a : cObject → dObject)
→ λ(b : cObject → dObject)
→ ∀(i : cObject) → dArrow (a i) (b i)
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./NonEmptyList</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>comonad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(nel : { head : a, tail : List a }) → a
, op :
      ∀(a : Type)
    → ∀(nel : { head : a, tail : List a })
    → { head :
          { head : a, tail : List a }
      , tail :
          List { head : a, tail : List a }
      }
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./NonEmptyList/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./NonEmptyList/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(f : a → b)
    → ∀(fa : { head : a, tail : List a })
    → { head : b, tail : List b }
}
</pre></dd>
</dl>
<h3>star (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(i : Type) → i → m i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : m b, _2 : m c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → m i
      }
    )
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(f : a → m b)
      → ∀(fa : { head : a, tail : List a })
      → m { head : b, tail : List b }
  }
</pre></dd>
</dl>
<h3>semigroup (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { op :
        ∀ ( p
          : { _1 :
                { head : a, tail : List a }
            , _2 :
                { head : a, tail : List a }
            }
          )
      → { head : a, tail : List a }
  }
</pre></dd>
</dl>
<h3>toList (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → ∀(nel : { head : a, tail : List a }) → List a
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → { head : a, tail : List a }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Optional</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>foldable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ fold :
      ∀(a : Type)
    → ∀(ts : Optional a)
    → ∀(b : Type)
    → ∀(f : a → b → b)
    → ∀(z : b)
    → b
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Optional/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./Optional/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ map :
    ∀(a : Type) → ∀(b : Type) → ∀(f : a → b) → ∀(fa : Optional a) → Optional b
}
</pre></dd>
</dl>
<h3>star (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(i : Type) → i → m i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : m b, _2 : m c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → m i
      }
    )
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(f : a → m b)
      → ∀(fa : Optional a)
      → m (Optional b)
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Optional/functor/toTypes</h2>
<h3>compactable (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>monad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → Optional a
, op :
    ∀(a : Type) → ∀(mma : Optional (Optional a)) → Optional a
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Pointed</h2>
<h2 style="background-color: #bbb; width: 100%">./Profunctor</h2>
<h3>fromDimap (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type → Type)
→ ∀ ( dimap
    :   ∀(a : Type)
      → ∀(b : Type)
      → ∀(c : Type)
      → ∀(d : Type)
      → (a → b)
      → (c → d)
      → f b c
      → f a d
    )
→ { dimap :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(c : Type)
      → ∀(d : Type)
      → (a → b)
      → (c → d)
      → f b c
      → f a d
  , lmap :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → ∀(fn : a → b) → f b c → f a c
  , rmap :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(f : Type → Type → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(f : Type → Type → Type)
→ { dimap :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(c : Type)
      → ∀(d : Type)
      → (a → b)
      → (c → d)
      → f b c
      → f a d
  , lmap :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (a → b) → f b c → f a c
  , rmap :
      ∀(a : Type) → ∀(b : Type) → ∀(c : Type) → (b → c) → f a b → f a c
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Ran</h2>
<h2 style="background-color: #bbb; width: 100%">./Ran/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./Ran/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀(g : Type → Type)
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(h : a → b)
      → ∀(ran : ∀(b : Type) → (a → f b) → g b)
      → ∀(c : Type)
      → ∀(k : b → f c)
      → g c
  }
</pre></dd>
</dl>
<h3>lower (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀(g : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(i : Type) → i → f i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : f b, _2 : f c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → f i
      }
    )
→ ∀(a : Type)
→ ∀(ran : ∀(b : Type) → (a → f b) → g b)
→ g a
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(f : Type → Type) → ∀(g : Type → Type) → ∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(f : Type → Type)
→ λ(g : Type → Type)
→ λ(a : Type)
→ ∀(b : Type) → (a → f b) → g b
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Reader</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>ask (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(r : Type) → ∀(env : r) → r
</pre></dd>
</dl>
<h3>asks (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(r : Type) → ∀(a : Type) → ∀(f : r → a) → ∀(env : r) → a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Reader/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./Reader/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ { map :
      ∀(a : Type) → ∀(b : Type) → ∀(f : a → b) → ∀(fa : r → a) → ∀(rr : r) → b
  }
</pre></dd>
</dl>
<h3>local (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(r : Type) → ∀(a : Type) → ∀(f : r → r) → ∀(reader : r → a) → ∀(env : r) → a
</pre></dd>
</dl>
<h3>monad (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>package.dhall (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(r : Type) → ∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(r : Type) → λ(a : Type) → r → a
</pre></dd>
</dl>
<h3>withReader (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ ∀(a : Type)
→ ∀(rPrime : Type)
→ ∀(f : rPrime → r)
→ ∀(reader : r → a)
→ ∀(newR : rPrime)
→ a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./ReaderT</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>ask (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(i : Type) → i → m i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : m b, _2 : m c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → m i
      }
    )
→ ∀(env : r)
→ m r
</pre></dd>
</dl>
<h3>asks (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ ∀(m : Type → Type)
→ ∀ ( applicative
    : { identity :
          ∀(i : Type) → i → m i
      , op :
            ∀(i : Type)
          → (   ∀(r : Type)
              → (   ∀(b : Type)
                  → ∀(c : Type)
                  → { _1 : m b, _2 : m c, _3 : b → c → i }
                  → r
                )
              → r
            )
          → m i
      }
    )
→ ∀(a : Type)
→ ∀(f : r → a)
→ ∀(env : r)
→ m a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./ReaderT/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./ReaderT/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ ∀(m : Type → Type)
→ ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b })
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(k : a → b)
      → ∀(fa : r → m a)
      → ∀(rr : r)
      → m b
  }
</pre></dd>
</dl>
<h3>local (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ ∀(m : Type → Type)
→ ∀(a : Type)
→ ∀(f : r → r)
→ ∀(reader : r → m a)
→ ∀(env : r)
→ m a
</pre></dd>
</dl>
<h3>monad (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>package.dhall (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./ReaderT/pointed</h2>
<h3>transformer (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ { lift :
        ∀(m : Type → Type)
      → ∀ ( monad
          : { identity :
                ∀(i : Type) → i → m i
            , op :
                ∀(i : Type) → m (m i) → m i
            }
          )
      → ∀(a : Type)
      → ∀(ma : m a)
      → ∀(env : r)
      → m a
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(r : Type) → ∀(m : Type → Type) → ∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(r : Type) → λ(m : Type → Type) → λ(a : Type) → r → m a
</pre></dd>
</dl>
<h3>withReader (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(r : Type)
→ ∀(m : Type → Type)
→ ∀(a : Type)
→ ∀(rPrime : Type)
→ ∀(f : rPrime → r)
→ ∀(reader : r → m a)
→ ∀(newR : rPrime)
→ m a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./scripts</h2>
<h2 style="background-color: #bbb; width: 100%">./Semigroup</h2>
<h3>Set (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(m : Type) → { op : { _1 : m, _2 : m } → m }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(product : object → object → object)
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(product : object → object → object)
→ λ(m : object)
→ { op : arrow (product m m) m }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Semigroupoid</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(object : Kind) → ∀(morphism : object → object → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(morphism : object → object → Type)
→ { compose :
        ∀(a : object)
      → ∀(b : object)
      → ∀(c : object)
      → morphism b c
      → morphism a b
      → morphism a c
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Star</h2>
<h3>category (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>semigroupoid (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : object → object → Type)
→ ∀(m : object → object)
→ ∀(a : object)
→ ∀(b : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : object → object → Type)
→ λ(m : object → object)
→ λ(a : object)
→ λ(b : object)
→ arrow a (m b)
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./State</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>eval (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>exec (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./State/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./State/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(s : Type)
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(f : a → b)
      → ∀(fa : s → { state : s, val : a })
      → ∀(new : s)
      → { state : s, val : b }
  }
</pre></dd>
</dl>
<h3>get (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(s : Type) → ∀(env : s) → { state : s, val : s }
</pre></dd>
</dl>
<h3>gets (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>modify (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>monad (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>package.dhall (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>put (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(s : Type) → ∀(new : s) → ∀(env : s) → { state : s, val : {} }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(s : Type) → ∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(s : Type) → λ(a : Type) → s → { state : s, val : a }
</pre></dd>
</dl>
<h3>withState (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(s : Type)
→ ∀(a : Type)
→ ∀(f : s → s)
→ ∀(state : s → { state : s, val : a })
→ ∀(new : s)
→ { state : s, val : a }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./StateT</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>eval (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>exec (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./StateT/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./StateT/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(s : Type)
→ ∀(m : Type → Type)
→ ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b })
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(f : a → b)
      → ∀(fa : s → m { state : s, val : a })
      → ∀(new : s)
      → m { state : s, val : b }
  }
</pre></dd>
</dl>
<h3>get (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(s : Type)
→ ∀(m : Type → Type)
→ ∀ ( monad
    : { identity : ∀(i : Type) → i → m i, op : ∀(i : Type) → m (m i) → m i }
    )
→ ∀(env : s)
→ m { state : s, val : s }
</pre></dd>
</dl>
<h3>gets (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>modify (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>monad (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>package.dhall (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>put (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(s : Type)
→ ∀(m : Type → Type)
→ ∀ ( monad
    : { identity : ∀(i : Type) → i → m i, op : ∀(i : Type) → m (m i) → m i }
    )
→ ∀(new : s)
→ ∀(env : s)
→ m { state : s, val : {} }
</pre></dd>
</dl>
<h3>transformer (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(s : Type) → ∀(m : Type → Type) → ∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(s : Type) → λ(m : Type → Type) → λ(a : Type) → s → m { state : s, val : a }
</pre></dd>
</dl>
<h3>withState (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(s : Type)
→ ∀(m : Type → Type)
→ ∀(a : Type)
→ ∀(f : s → s)
→ ∀(state : s → m { state : s, val : a })
→ ∀(new : s)
→ m { state : s, val : a }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Strong</h2>
<h3>extractProfunctor (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : { _1 : dObject, _2 : cObject } → Type)
→ ∀ ( strong
    : { lmap :
            ∀(a : dObject)
          → ∀(b : dObject)
          → ∀(c : cObject)
          → dArrow b a
          → f { _1 = a, _2 = c }
          → f { _1 = b, _2 = c }
      , map :
            ∀(a : { _1 : dObject, _2 : cObject })
          → ∀(b : { _1 : dObject, _2 : cObject })
          → { _1 : dArrow b._1 a._1, _2 : cArrow a._2 b._2 }
          → f a
          → f b
      , rmap :
            ∀(a : dObject)
          → ∀(b : cObject)
          → ∀(c : cObject)
          → cArrow b c
          → f { _1 = a, _2 = b }
          → f { _1 = a, _2 = c }
      }
    )
→ { map :
        ∀(a : { _1 : dObject, _2 : cObject })
      → ∀(b : { _1 : dObject, _2 : cObject })
      → { _1 : dArrow b._1 a._1, _2 : cArrow a._2 b._2 }
      → f a
      → f b
  }
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cArrow : cObject → cObject → Type)
→ ∀(dObject : Kind)
→ ∀(dArrow : dObject → dObject → Type)
→ ∀(f : { _1 : dObject, _2 : cObject } → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(cArrow : cObject → cObject → Type)
→ λ(dObject : Kind)
→ λ(dArrow : dObject → dObject → Type)
→ λ(f : { _1 : dObject, _2 : cObject } → Type)
→ { lmap :
        ∀(a : dObject)
      → ∀(b : dObject)
      → ∀(c : cObject)
      → dArrow b a
      → f { _1 = a, _2 = c }
      → f { _1 = b, _2 = c }
  , map :
        ∀(a : { _1 : dObject, _2 : cObject })
      → ∀(b : { _1 : dObject, _2 : cObject })
      → { _1 : dArrow b._1 a._1, _2 : cArrow a._2 b._2 }
      → f a
      → f b
  , rmap :
        ∀(a : dObject)
      → ∀(b : cObject)
      → ∀(c : cObject)
      → cArrow b c
      → f { _1 = a, _2 = b }
      → f { _1 = a, _2 = c }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Transformer</h2>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(t : (Type → Type) → Type → Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(t : (Type → Type) → Type → Type)
→ { lift :
        ∀(m : Type → Type)
      → ∀ ( monad
          : { identity :
                ∀(i : Type) → i → m i
            , op :
                ∀(i : Type) → m (m i) → m i
            }
          )
      → ∀(a : Type)
      → m a
      → t m a
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./translation</h2>
<h2 style="background-color: #bbb; width: 100%">./Traversable</h2>
<h2 style="background-color: #bbb; width: 100%">./Tuple</h2>
<h3>comonad (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { identity :
      ∀(b : Type) → ∀(tup : { _1 : a, _2 : b }) → b
  , op :
        ∀(a : Type)
      → ∀(tup : { _1 : a@1, _2 : a })
      → { _1 : a@1, _2 : { _1 : a@1, _2 : a } }
  }
</pre></dd>
</dl>
<h3>curry (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(c : Type)
→ ∀(f : { _1 : a, _2 : b } → c)
→ ∀(x : a)
→ ∀(y : b)
→ c
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Tuple/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./Tuple/functor/endo</h2>
<h3>star (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b })
→ ∀(a : Type)
→ { map :
        ∀(b : Type)
      → ∀(c : Type)
      → ∀(f : b → m c)
      → ∀(t : { _1 : a, _2 : b })
      → m { _1 : a, _2 : c }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Tuple/functor/fromProduct</h2>
<h3>pair (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → ∀(b : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → λ(b : Type) → { _1 : a, _2 : b }
</pre></dd>
</dl>
<h3>uncurry (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(c : Type)
→ ∀(f : a → b → c)
→ ∀(t : { _1 : a, _2 : b })
→ c
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Yoneda</h2>
<h3>applicative (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>foldable (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀ ( foldable
    : { fold :
            ∀(a : Type)
          → ∀(ts : f a)
          → ∀(b : Type)
          → ∀(f : a → b → b)
          → ∀(z : b)
          → b
      }
    )
→ { fold :
        ∀(a : Type)
      → ∀(yoneda : ∀(b : Type) → (a → b) → f b)
      → ∀(b : Type)
      → ∀(k : a → b → b)
      → ∀(z : b)
      → b
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Yoneda/functor</h2>
<h2 style="background-color: #bbb; width: 100%">./Yoneda/functor/endo</h2>
<h3>set (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(h : a → b)
      → ∀(ran : ∀(b : Type) → (a → b) → f b)
      → ∀(c : Type)
      → ∀(k : b → c)
      → f c
  }
</pre></dd>
</dl>
<h3>star (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀(mFunctor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → m a → m b })
→ ∀(f : Type → Type)
→ ∀(fFunctor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → f a → f b })
→ ∀(fFunctorK : { map : ∀(a : Type) → ∀(b : Type) → (a → m b) → f a → m (f b) })
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(fn : a → m b)
      → ∀(fa : ∀(b : Type) → (a → b) → f b)
      → m (∀(b : Type) → (b@1 → b) → f b)
  }
</pre></dd>
</dl>
<h3>lift (term)</h3>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀(functor : { map : ∀(a : Type) → ∀(b : Type) → (a → b) → f a → f b })
→ ∀(a : Type)
→ ∀(fa : f a)
→ ∀(b : Type)
→ ∀(k : a → b)
→ f b
</pre></dd>
</dl>
<h3>lower (term)</h3>
<dl>
<dt>type</dt><dd><pre>
∀(f : Type → Type) → ∀(a : Type) → ∀(ran : ∀(b : Type) → (a → b) → f b) → f a
</pre></dd>
</dl>
<h3>monad (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h3>Type (type)</h3>
<dl>
<dt>kind</dt><dd><pre>
∀(g : Type → Type) → ∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(g : Type → Type) → λ(a : Type) → ∀(b : Type) → (a → b) → g b
</pre></dd>
</dl>
</body></html>
